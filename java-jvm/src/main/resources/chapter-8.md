### 虚拟机字节码执行引擎
代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步

#### 概述
执行引擎是 Java 虚拟机最核心的组成部分之一, 虚拟机是一个相对于物理机的概念, 这两种机器都有代码执行能力, 其区别是物理机的执行引擎是直接建立在处理器, 硬件, 指令集和操作系统层面上的, 而虚拟机的执行引擎则是自己实现的, 因此可以自行制定指令集与执行引擎的结构体系, 并且能够执行那些不被硬件直接支持的指令集格式  
在 Java 虚拟机规范中制定的了字节码执行引擎的概念模型, 在不同的虚拟机实现里, 执行引擎在执行 Java 代码的时候可能会有解释执行 (解释器执行) 和编译执行 (通过即使编译器产生本地代码执行)  两种选择; 但所有的 Java 虚拟机的执行引擎都是一致的: 输入的是字节码文件, 处理过程是字节码解析的等效过程, 输出的是执行结果

#### 执行时栈帧结构
栈帧 (Stack Frame) 是用于支持虚拟机进行方法调用和方法执行的数据结构, 它是虚拟机运行时数据区中的虚拟机栈 (Virtual Machine Stack) 的栈元素; 栈帧存储了方法的局部变量表, 操作数栈, 动态连接和方法返回地址等信息; 每一个方法从调用开始至执行完成的过程, 都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程  
每一个栈帧都包括了局部变量表, 操作数栈, 动态连接, 方法返回地址和一些额外的附加信息; 在编译程序代码时, 栈帧中需要多大的局部变量表, 多深的操作数栈都已经完全确定了, 并且写入到方法表的 Code 属性中, 因此一个栈帧需要分配多少内存, 不会受到程序运行期变量数据的影响, 而仅仅取决于具体的虚拟机实现  
一个线程中的方法调用链可能会很长, 很多方法都同时处于执行状态; 对于执行引擎来说, 在活动线程中, 只有位于栈顶的栈帧才是有效的, 称为当前栈帧, 与这个栈帧相关联的方法称为当前方法; 执行引擎运行的所有字节码指令都只针对当前栈帧进行操作

#####局部变量表  
局部变量表 (Local Variable Table) 是一组变量值存储空间, 用于存放方法参数和方法内部定义的局部变量; 在 Java 程序编译为 Class 文件时就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量  
局部变量表的容量以变量槽 (Variable Slot) 为最小单位, 虚拟机规范中并没有明确指明一个 Slot 应占用的内存空间大小, 只是很有导向性地说到每个 Slot 都应该能存放一个 boolean, byte, char, short, int, float, reference 或 returnAddress 类型的数据; 这 8 种数据类型都可以使用 32 位或更小的物理内存来存放, 但这种描述与明确指出 "每个 Slot 占用 32 位长度的内存空间" 是有一定差别的  
所说的 8 种数据类型前 6 种按照 Java 语言种对应数据类型的概念去理解即可, 第 7 种 reference 类型表示对一个对象实例的引用, 虚拟机规范既没有说明它的长度, 也没有明确指出这种引用应有怎样的结构; 但一般来说, 虚拟机实现至少都应当能通过这个引用做到两点: 一是从此引用中直接或间接的查找到对象在 Java 堆中的数据存放的起始地址索引, 二是此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息, 否则无法实现 Java 语言规范定义的语法约束; 第 8 种即 returnAddress 类型已经很少见了, 它是位字节指令 jsr, jsr_w 和 ret 服务的, 指向了一条字节码指令的地址, 很古老的 Java 虚拟机曾经使用这几条指令来实现异常处理, 现在已经由异常表代替  
对于 64 位的数据类型, 虚拟机会以高位对齐的方式位其分配两个连续的 Slot 空间, Java 语言中明确的 (reference 类型则可能是 32 位也可能是 64 位) 64 位数据类型只有 long 和 duoble 两种; 这里把 long 和 double 数据类型分割存储的做法与 "long 和 double 的非原子性协定" 中把一次 long 和 double 数据类型读写分割成两次 32 位读写的做法类似; 由于局部变量表建立在线程的堆栈上, 是线程私有的数据, 无论读写两个连续的 Slot 是否位原子操作, 都不会引起数据安全问题  
在方法执行时, 虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程, 如果执行的是实例方法 (非 static 的方法), 那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属实例的引用, 在方法中可以通过关键字 "this" 来访问到这个隐含的参数, 其余参数则按照参数表顺序排列, 参数表分配完毕后, 再根据方法体内部定义的变量顺序和作用域分配其余 Slot  
为了尽可能节省栈帧空间, 局部变量表中的 Slot 是可以重用的, 方法体中定义的变量, 其作用域并不一定会覆盖整个方法体, 如果当前字节码 PC 计数器的值已经超出了某个变量的作用域, 那这个变量对应的 Slot 就可以交给其他变量使用; 这样的设计 除了节省栈帧空间以外, 还伴随着一些额外的副作用; 例如, 在某些情况下, Slot 复用会直接影响到系统的垃圾收集行为
```
public static void main(String[] args) {
    byte[] placeHolder = new byte[64 * 1024 * 1024];
    System.gc();
}

// GC 信息如下
[GC (System.gc())  68865K->66288K(125952K), 0.0007677 secs]
[Full GC (System.gc())  66288K->66222K(125952K), 0.0178481 secs]
```
执行 System.gc() 时, 变量 placeHolder 还在作用域内, 虚拟机自然是不会回收 placeHolder 的内存的; 继续把代码修改如下
```
public static void main(String[] args) {
    {
        byte[] placeHolder = new byte[64 * 1024 * 1024];
    }
    System.gc();
}

// GC 信息如下
[GC (System.gc())  68865K->66320K(125952K), 0.0011311 secs]
[Full GC (System.gc())  66320K->66222K(125952K), 0.0045486 secs]
```
placeHolder 作用域被限制在花括号内, 从代码逻辑上讲, 在执行 System.gc() 时, placeHolder 已经不能再被访问了, 当内存仍然还没有被回收; 继续修改代码如下
```
public static void main(String[] args) {
    {
        byte[] placeHolder = new byte[64 * 1024 * 1024];
    }
    int a = 0;
    System.gc();
}

// GC 信息如下
[GC (System.gc())  68865K->66320K(125952K), 0.0011931 secs]
[Full GC (System.gc())  66320K->686K(125952K), 0.0045929 secs]
```
这个修改看起来很莫名奇妙, 但是运行发现 GC 时 placeHolder 的内存真正的被回收了  
placeHolder 能被回收的根本原因是: 局部变量表中的 Slot 是否还存有关于 placeHolder 数据对象的引用; 第一次修改中, 代码虽然已经离开了 placeHolder 的作用域, 但在此之后, 没有任何对局部变量表的读写操作, placeHolder 原本所占用的 Slot 还没有被其他变量所复用, 所以作为 GC Root 一部分的局部变量表仍然保持着对它的关联; 这种关联没有即时被打断在大部分情况下影响都很轻微  
关于局部变量表, 还有一点可能会对实际开发产生影响, 就是局部变量不像前面介绍的类变量那样存在 "准备阶段", 类变量有两次赋初始值的过程, 因此在初始化阶段没有为类变量赋值, 类变量仍然具有一个确定的初始值; 但局部变量就不一样, 如果一个局部变量定义了但没有赋初始值是不能使用的

##### 操作数栈
 操作数栈 (Operand Stack) 也常称为操作栈, 是一个后入先出 (Last In First Out, LIFO) 栈; 同局部变量表一样, 操作数栈的最大深度也在编译的时候写入到 Code 属性的 max_stacks 数据项中; 操作数栈的每一个元素可以是任意的 Java 数据类型, 包括 long 和 double; 32 位数据类型占栈容量为 1, 64 位数据类型所占栈的容量为 2; 在方法执行的任何时候, 操作数栈的深度都不会超过 max_stacks数据项中设定的最大值
