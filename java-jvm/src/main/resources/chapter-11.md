### 晚期 (运行期) 优化
从计算机程序出现的第一天起, 对效率的追求就是程序天生的坚定信仰, 这个过程犹如一场没有终点, 永不停歇的 F1 方程式竞赛, 程序员是车手, 技术平台则是赛道上飞驰的赛车

#### 概述
在部分商用虚拟机中 (Sun HotSpot, IBM J9) 中, Java 程序最初是通过解释器进行解释执行的, 当虚拟机发现某个方法或代码块的运行特别频繁时, 就会把这些代码认定为 "热点代码" (Hot Spot Code); 为了提高热点代码的执行效率, 在运行时, 虚拟机将会把这些代码编译为与本地平台相关的机器码, 并进行各种层次的优化, 完成这个任务的编译器称为即时编译器 (Just In Time Compiler, JIT 编译器)  
即时编译器并不是虚拟机必需的部分, Java 虚拟机规范中并没有规定 Java 虚拟机内必须要有即时编译器存在, 更没有限定或指导即时编译器应该如何去实现; 但是, 即时编译器编译性能的好坏, 代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一, 也是虚拟机中最核心且最能体现虚拟机技术水平的部分  

#### HotSpot 虚拟机内的即时编译器
- 为何 HotSpot 虚拟机要使用解释器与编译器并存的架构
- 为何 HotSpot 虚拟机要实现两个不同的即时编译器
- 程序何时使用解释器执行, 何时使用编译器执行
- 哪些程序代码会被编译为本地代码, 如何编译为本地代码
- 如何从外部观察即时编译器的编译过程和编译结果

#### 解释器与编译器
解释器和编译器两者各有优势: 当程序需要快速启动和执行的时候, 省去编译的时间, 立即执行; 在程序运行之后, 随着时间的推移, 编译器逐渐发挥作用, 把越来越多的代码编译成本地代码之后, 可以获取更高的执行效率; 当程序运行环境中内存资源限制较大 (如部分嵌入式系统中), 可已使用解释执行节约内存, 反之可以使用编译执行来提升效率; 同时, 解释器还可以作为编译器激进优化时的一个 "逃生门", 让编译器依据概率选择一些大多数时候都能提升运行速度的优化手段, 当激进优化的假设不成立, 如加载了新类后类型继承结构出现变化, 出现 "罕见陷阱" 时可以通过逆优化退回到解释器状态继续执行 (部分没有解释器的虚拟机中也会采用不进行激进优化的 C1 编译器担任 "逃生门" 的角色); 因此, 在整个虚拟机架构中解释器与编译器经常配合工作
```
                                       |---------编译器---------|  
  |---- 解释器 ----| ---即时编译 --->   |  Client Compiler (C1)  |
  |  Interpreter  |                    |                        |
  |---------------| <--- 逆优化 ---    |  Server Compiler (C2)  |
                                       |------------------------|  
```
