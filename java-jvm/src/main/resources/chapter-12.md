### Java 内存模型与线程
并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因, 也是人类 "压榨" 计算机运行能力的最有力的武器

#### 概述
由于计算机运算速度与它的存储和通信子系统速度的差距很大, 大量的时间都花费在磁盘 I/O, 网络通信或者数据库访问上, 为了避免造成处理器的资源浪费, 并行处理被证明是非常有效的压榨手段; 除了充分利用计算处理器的能力外, 一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景, 衡量一个服务性能的好坏, 每秒事务处理数 (Transactions Per Second, TPS) 是最重要的指标之一, 它代表着一秒内服务端平均能响应的请求总数, 而 TPS 值与程序的并发能力又有非常密切的关系; 高效并发将会介绍虚拟机如何实现多线程, 多线程之间由于共享和竞争数据而导致的一系列问题及解决方案

#### 硬件的效率与一致性
"让计算机并发执行若干个运算任务" 与 "更充分地利用计算机处理器的效能" 之间的因果关系, 实际上这之间的关系并没有那么简单, 其中一个重要的复杂性来源是绝大多数运算任务都不可能只靠处理器计算完成, 与内存交互, 如读取数据, 存储计算结果等, I/O 操作是很难消除的; 由于存储设备和处理器的运算速度相差好几个量级, 所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲: 将运算需要使用到的数据复制到缓存中, 让运算能快速进行, 当运算结束后再从缓存同步到内存中, 这样处理器就无须等待缓慢的内存读写了  
基于高速缓存的存储交互很好的解决了处理器与内存的读写速度矛盾, 但是也为计算机系统带来了更高的复杂度, 因为引入了新的问题: 缓存一致性 (Cache Coherence); 在多处理器系统中, 每个处理器都有自己的高度缓存, 而它们又共享同一内存 (Main Memory), 当多个处理器的运算任务都涉及同一块内存区域时, 将可能导致各自的缓存数据不一致; 为了解决一致性问题, 需要各个处理器在访问缓存数据时遵循一些协议, 在读写时要根据协议来进行操作, 这类协议有 MSI, MESI, MOSI, Synape, Firefly 或 Dragon Protocol 等; 内存模型可以理解为在特定的操作协议下, 对特定的内存或高速缓存进行读写访问的过程抽象  
除了增加高速缓存之外, 为了使处理器内部的运算的单元能尽量被充分利用, 处理器可能会对输入代码进行乱序执行 (Out-Of-Order Execution) 优化, 处理器会在计算之后将乱序执行的结果重组, 保证该结果和顺序执行的结果是一致的; 因此, 如果存在一个计算任务依赖另外一个计算任务的中间结果, 那么其顺序性并不能靠代码的先后顺序来保证; 与处理器的乱序执行优化类似, Java 虚拟机的即时编译器中也有类似的指令重排序优化

#### Java 内存模型
Java 虚拟机规范中试图定义一种 Java 内存模型 (Java Memory Model, JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异, 以实现让 Java 程序在各种平台下都能达到一致的内存访问效果; 定义 Java 内存模型不是一件容易的事, 这个模型必须定义的足够严谨, 才能让 Java 的并发内存访问操作不会产生歧义; 但是, 也必须定义的足够宽松, 使得虚拟机的实现有足够的自由空间去利用硬件的各种特性来获取更好的执行速度; 经过长时间的修补, 在 JDK 1.5 (实现了 JSR-133) 发布后, Java 内存模型已经成熟和完善起来了

##### 主内存与工作内存
Java 内存模型的主要目标是定义程序中各个变量的访问规则, 即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节; 此处的变量 (Variable) 与 Java 中的所说的变量有所区别, 它包括了实例字段, 静态字段和构成数组对象的元素, 但不包括局部变量与方法参数, 后者是线程私有的, 不会被共享, 自然也不会存在竞争问题; 为了获得较好的执行性能, Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互, 也没有限制即时编译器进行调整代码执行顺序这类优化措施  
Java 内存模型规定了所有变量都存储在主存 (Main Memory) 中; 每条线程还有自己的工作内存, 线程的工作内存中保存了该线程使用到的变量的主存副本拷贝, 线程对变量的所有操组都必须在工作内存中进行, 而不能直接读写主存中的变量; 不同线程之间也无法直接访问对方工作内存中的变量, 线程间变量值的传递均需要通过主存来完成; 线程, 主存, 工作内存三者的交互关系如下
```

|Java 线程|  <--->   |工作内存|  <--->  |    |         |     |
                                       |Save|         |     |
|Java 线程|  <--->   |工作内存|  <--->  |和  |  <--->  |主内存|
                                       |Load|         |     |
|Java 线程|  <--->   |工作内存|  <--->  |    |         |     |

```

##### 内存间交互操作
关于主存与工作内存之间具体的交互协议, 即一个变量如何从主内存拷贝到工作内存中, 如何从工作内存中同步回主存中的实现细节, Java 内存模型定义了以下 8 种操作来完成, 虚拟机实现时必须保证下面提及的每一种操作都是原子的, 不可再分的 (对于 duoble 和 long 类型来说, load, store, read 和 write 操作在某些平台上允许有例外)
- Lock (锁定): 
