### Java 内存模型与线程
并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因, 也是人类 "压榨" 计算机运行能力的最有力的武器

#### 概述
由于计算机运算速度与它的存储和通信子系统速度的差距很大, 大量的时间都花费在磁盘 I/O, 网络通信或者数据库访问上, 为了避免造成处理器的资源浪费, 并行处理被证明是非常有效的压榨手段; 除了充分利用计算处理器的能力外, 一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景, 衡量一个服务性能的好坏, 每秒事务处理数 (Transactions Per Second, TPS) 是最重要的指标之一, 它代表着一秒内服务端平均能响应的请求总数, 而 TPS 值与程序的并发能力又有非常密切的关系; 高效并发将会介绍虚拟机如何实现多线程, 多线程之间由于共享和竞争数据而导致的一系列问题及解决方案

#### 硬件的效率与一致性
"让计算机并发执行若干个运算任务" 与 "更充分地利用计算机处理器的效能" 之间的因果关系, 实际上这之间的关系并没有那么简单, 其中一个重要的复杂性来源是绝大多数运算任务都不可能只靠处理器计算完成, 与内存交互, 如读取数据, 存储计算结果等, I/O 操作是很难消除的; 由于存储设备和处理器的运算速度相差好几个量级, 所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲: 将运算需要使用到的数据复制到缓存中, 让运算能快速进行, 当运算结束后再从缓存同步到内存中, 这样处理器就无须等待缓慢的内存读写了  
基于高速缓存的存储交互很好的解决了处理器与内存的读写速度矛盾, 但是也为计算机系统带来了更高的复杂度, 因为引入了新的问题: 缓存一致性 (Cache Coherence); 在多处理器系统中, 每个处理器都有自己的高度缓存, 而它们又共享同一内存 (Main Memory), 当多个处理器的运算任务都涉及同一块内存区域时, 将可能导致各自的缓存数据不一致; 为了解决一致性问题, 需要各个处理器在访问缓存数据时遵循一些协议, 在读写时要根据协议来进行操作, 这类协议有 MSI, MESI, MOSI, Synape, Firefly 或 Dragon Protocol 等; 内存模型可以理解为在特定的操作协议下, 对特定的内存或高速缓存进行读写访问的过程抽象  
除了增加高速缓存之外, 为了使处理器内部的运算的单元能尽量被充分利用, 处理器可能会对输入代码进行乱序执行 (Out-Of-Order Execution) 优化, 处理器会在计算之后将乱序执行的结果重组, 保证该结果和顺序执行的结果是一致的; 因此, 如果存在一个计算任务依赖另外一个计算任务的中间结果, 那么其顺序性并不能靠代码的先后顺序来保证; 与处理器的乱序执行优化类似, Java 虚拟机的即时编译器中也有类似的指令重排序优化

#### Java 内存模型
Java 虚拟机规范中试图定义一种 Java 内存模型 (Java Memory Model, JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异, 以实现让 Java 程序在各种平台下都能达到一致的内存访问效果; 定义 Java 内存模型不是一件容易的事, 这个模型必须定义的足够严谨, 才能让 Java 的并发内存访问操作不会产生歧义; 但是, 也必须定义的足够宽松, 使得虚拟机的实现有足够的自由空间去利用硬件的各种特性来获取更好的执行速度; 经过长时间的修补, 在 JDK 1.5 (实现了 JSR-133) 发布后, Java 内存模型已经成熟和完善起来了

##### 主内存与工作内存
Java 内存模型的主要目标是定义程序中各个变量的访问规则, 即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节; 此处的变量 (Variable) 与 Java 中的所说的变量有所区别, 它包括了实例字段, 静态字段和构成数组对象的元素, 但不包括局部变量与方法参数, 后者是线程私有的, 不会被共享, 自然也不会存在竞争问题; 为了获得较好的执行性能, Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互, 也没有限制即时编译器进行调整代码执行顺序这类优化措施  
Java 内存模型规定了所有变量都存储在主内存 (Main Memory) 中; 每条线程还有自己的工作内存, 线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝, 线程对变量的所有操组都必须在工作内存中进行, 而不能直接读写主内存中的变量; 不同线程之间也无法直接访问对方工作内存中的变量, 线程间变量值的传递均需要通过主内存来完成; 线程, 主内存, 工作内存三者的交互关系如下
```

|Java 线程|  <--->   |工作内存|  <--->  |    |         |     |
                                       |Save|         |     |
|Java 线程|  <--->   |工作内存|  <--->  |和  |  <--->  |主内存|
                                       |Load|         |     |
|Java 线程|  <--->   |工作内存|  <--->  |    |         |     |

```

##### 内存间交互操作
关于主内存与工作内存之间具体的交互协议, 即一个变量如何从主内存拷贝到工作内存中, 如何从工作内存中同步回主内存中的实现细节, Java 内存模型定义了以下 8 种操作来完成, 虚拟机实现时必须保证下面提及的每一种操作都是原子的, 不可再分的 (对于 duoble 和 long 类型来说, load, store, read 和 write 操作在某些平台上允许有例外)
- lock (锁定): 作用于主内存的变量, 它把一个变量标识为一个线程独占的状态
- unlock (解锁): 作用于主内存的变量, 它把一个处于锁定状态的变量释放出来, 释放后的变量才可以被其他线程锁定
- read (读取): 作用于主内存的变量, 它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中
- load (载入): 作用于工作内存的变量, 它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中
- use (使用): 作用于工作内存的变量, 它把工作内存中的一个变量的值传递给执行引擎, 每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
- assign (赋值): 作用于工作内存的变量, 它把一个从执行引擎接收到的值赋给工作内存的变量, 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
- store (存储): 作用于工作内存的变量, 它把工作内存中一个变量的值传送到主内存中, 以便随后的 write 操作使用
- write (写入): 作用于主内存的变量, 它把 store 操作从工作内存中得到的变量的值放入主内存的变量中

如果要把一个变量从主内存复制到工作内存, 那就要顺序地执行 read 和 load 操作, 如果要把变量从工作内存同步会主内存, 就要顺序地执行 store 和 write 操作; Java 内存模型只要求上述两个操作必须按顺序执行, 而没有保证是连续执行的; 除此之外, Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则
- 不允许 read 和 load, store 和 write 操作之一单独出现, 即不允许一个变量从主内存读取了但工作内存不接受, 或者从工作内存发起了回写但主内存不接受的情况出现
- 不允许一个线程丢弃它的最近的 assign 操作, 即变量在工作内存中改变了之后必须把该变化同步回主内存
- 不允许一个线程无原因的 (没有发生过任何 assign 操作) 把数据从线程的工作内存同步回主内存
- 一个新的变量只能在主内存中 "诞生", 不允许在工作内存中直接使用一个未被初始化 (load 或 assign) 的变量, 也就是对一个变量实施 use, store 操作之前, 必须先执行过了 assign 和 load 操作
- 一个变量在同一时刻只允许一条线程对其进行 lock 操作, 但 lock 操作可以被同一条线程重复执行多次, 多次执行 lock 后, 只有执行相同次数的 unlock 操作, 变量才会被解锁
- 如果对一个变量执行 lock 操作, 那将会清空工作内存中此变量的值, 在执行引擎使用这个变量前, 需要重新执行 load 或 assign 操作初始化变量的值
- 如果一个变量事先没有被 lock 操作锁定, 那就不允许对它执行 unlock 操作, 也不允许去 unlock 一个被其他线程锁定住的变量
- 对一个变量执行 unlock 操作之前, 必须先把此变量同步回主内存中 (执行 store, write 操作)

以上 8 种内存访问操作以及上述规则限定, 再加上 volatile 的一些规定, 就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的; 由于这种定义相当严谨, 但又十分繁琐, 实践起来非常麻烦, 以下将会介绍一个等效判定原则 ---  先行发生原则, 用来确定一个访问在并发环境下是否安全

##### 对于 volatile 型变量的特殊规则
关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制, 但是它并不容易被理解; 当一个变量定义为 volatile 之后, 它将具备两种特性

###### 可见性
第一是保证此变量对所有线程的可见性, 这里的可见性是指当一条线程修改了这个变量的值, 新值对于其他线程来说是可以立即得知的; 而普通变量则不能做到这一点, 普通变量的值在线程间传递均需要通过主内存来完成, 例如: 线程 A 修改了一个普通变量的值, 然后向主内存进行回写, 另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作, 新变量值才会对线程 B 可见    
关于 volatile 变量的可见性, 经常会被认为 "volatile 变量对所有线程是立即可见的, 对 volatile 变量的所有写操作都能立刻反应到其他线程中", 换句话说就是 "volatile 变量在各个线程中是一致的, 所以基于 volatile 变量的运算在并发下是安全的"; 这句话的论据没有错, 但是其论据不能得出 "基于 volatile 变量的运算在并发下是安全的" 这个结论; volatile 变量在各个线程额工作内存中不存在一致性问题 (在各个线程的工作内存中, volatile 变量也是可以存在不一致的情况, 但由于每次使用之气那都要先刷新, 执行引擎看不到不一致的情况, 因此可以认为不存在一致性问题), 但是 Java 中的运算并非原子操作, 所以导致 volatile 变量的运算在并发下一样是不安全的
```
public class VolatileTest {

    public static volatile int race = 0;

    public static void increase() {
        race++;
    }

    private static final int THREADS_COUNT = 20;

    public static void main(String[] args) {
        Thread[] threads = new Thread[THREADS_COUNT];
        for (int i = 0; i < THREADS_COUNT; i++) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 10000; j++) {
                        increase();
                    }
                }
            });
            threads[i].start();
        }

        // 等待所有线程结束
        while (Thread.activeCount() > 1) {
            Thread.yield();
        }

        System.out.println(race);
    }
}
```
这段代码并发起了 20 个线程, 如果能够正确执行那么最终的结果因该是 200000, 但实际上每次运行完都会发现输出的结果都不一样, 都是一个小于 200000 的值; 问题出在 race++ 这句代码中, 用 javap 反编译代码就会发现在 Class 文件中, 本只有一行代码的 increate() 方法是由 4 条字节码指令构成的 (return 指令不是 race++ 产生的, 不做计数), 从字节码层面很容易分析出原因: 当 getstatic 指令把 race 的值取到操作栈顶时, volatile 关键字保证了值此时是正确的, 但在执行 iconst_1, iadd 指令时其他线程可能把 race 的值加大了, 而栈顶的值就变成了过期的值, 所以 putstatic 指令执行后就可能把较小的 race 值同步回主内存之中
```
public static void increase();
  Code:
     0: getstatic     #2                  // Field race:I
     3: iconst_1
     4: iadd
     5: putstatic     #2                  // Field race:I
     8: return
  LineNumberTable:
    line 13: 0
    line 14: 8
```
这里使用字节码分析并发问题仍然是不严谨的, 因为即使编译出来只有一条字节码指令, 也并不意味着执行这条指令就是一个原子操作; 一条字节码指令在解释执行时, 解释器将要运行许多行代码才能实现它的语义, 如果是编译执行, 一条字节码指令也可能转化为多条本地机器码指令, 此处使用 -XX:+PrintAssembly 参数输出反汇编来分析更加严谨, 但字节码也已经足够发现问题了  
由于 volatile 变量只能保证可见性, 在不符合以下两条规则的运算场景总, 仍要通过加锁 (synchronized 和 java.util.concurrent 的原子类) 来保证原子性
- 运算结果并不依赖变量的当前值, 或者能够确保只有单一的线程修改变量的值
- 变量不需要与其他的状态变量共同参与不变约束

###### 禁止指令排序优化
第二是禁止指令排序优化, 普通的变量仅仅会保证在该方法的执行过程中所有依赖复制结果的地方都能获取到正确的结果, 而不能保证变量赋值操作的顺序与程序代码中执行顺序一致; 因为在一个线程的方法执行过程中无法感知到这一点, 这也是 Java 内存模型中描述的所谓的 "线程内表现为串行的语义" (Within-Thread As-If-Serial Semantics)
```
Map ocnfigOptions;
char[] configText;
// 此变量必须定义为 volatile
volatile boolean initialized = false;

// 假设以下代码在线程 A 中执行, 模拟读取配置信息, 当读取完成后将 initialized 设置为 true 以通知其他线程配置可用
configOptions = new HashMap();
configText = readConfigFile(fileName);
processConfigOptions(configText, configOptions);
initialized = true;

// 假设以下代码在线程 B 中执行, 等待 initialized 为 true, 代表线程 A 已经把配置信息初始化完成
while (!initialized) {
  sleep();
}
// 使用线程 A 中初始化好的配置信息
doSomethingWithConfig();
```
如果定义 initialized 变量时没有使用 volatile 修饰, 就可能会由于指令重排序的优化, 导致位于线程 A 中最后一句代码的 "initialized  = true" 被提前执行 (这里虽然使用 Java 作为伪代码, 但所指的重排序优化是机器级的优化操作, 提前执行是指这句话对应的汇编代码被提前执行), 这样在线程 B 中使用配置的信息的代码就可能出现错误, 而 volatile 关键字则可以避免此类情况发生 (JDK 1.5 后)  
指令重排序是并发编程中最容易让开发人员产生疑惑的地方, 以下是标准的 DCL 单例代码, 可以观察加入 volatile 和未加入 volatile 关键字时所生成汇编代码的区别
```
public class Singleton {
    private volatile static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    public static void main(String[] args) {
        Singleton.getInstance();
    }
}
```
JIT 的汇编代码如下
```
TODO...
```
通过对比就会发现, 关键变化在于有 volatile 修饰的变量, 赋值后 (mov %eax, 9x150 (%esi) 这句便是赋值操作) 多执行了一个 "lock addl $0x0, (%esp)" 操作, 这个操作相当于一个内存屏障 (Memory Barrier 或 Memory Fence, 指重排序时不能把后面的指令重排序到内存屏障之前的位置), 只有一个 CPU 访问内存时, 并不需要内存屏障; 但是有两个或者多个 CPU 访问同一块内存, 且其中只有一个在观测另一个, 就需要内存屏障来保证一致性了; 这句指令中的 "addl $0x0, (%esp)" (把 ESP 寄存器的值加 0) 显然是一个空操作 (采用这个空操作而不是空操作指令 nop 是因为 IA32 手册规定 lock 前缀不允许配合 nop 指令使用), 关键在于 lock 前缀, 它的作用是使得本 CPU 的 Cache 写入了内存, 该写入动作也会引起别的 CPU 或别的内核无效化其 Cache, 这种操作相当于对 Cache 中的变量做了一次 Java 内存模式中所说的 "store 和 write" 操作; 所以通过这样一个空操作, 可让前面的 volatile 变量的修改对其他 CPU 立即可见  
从硬件架构上来讲, 指令重排序是指 CPU 采用了允许将多条指令不按程序的顺序分开发送给各相应电路单元处理, 但并不是说指令任意重排, CPU 需要能正确处理指令依赖的情况以保障程序能够得出正确的执行结果; 譬如指令 1 把地址 A 中的值加 10, 指令 2 把地址 A 中的值乘以 2, 指令 3 把地址 B 中的值减去 3, 这时指令 1 和指令 2 是有依赖的, 它们之间的顺寻不能重排, 但指令 3 可以重排到指令 1, 2 之前或中间, 只要保证 CPU 执行后面依赖到 A, B 值的操作时能获取到正确的 A 和 B 的值即可; 所以在本 CPU 中, 重排序看起来依然是有序的; 因此 lock addl $0x0, (%esp) 指令把修改同步到内存时, 意味着所有之前的操作都已经执行完成, 这样便形成了 "指令重排序无法越过内存屏障" 的效果  
在某些情况下, volatile 的同步机制的性能确实要优于锁 (使用 synchronized 关键字或 java.util.concurrent 包里面的锁), 但是由于虚拟机对锁实行的许多消除和优化, 使得很难量化地认为 volatile 就会比 synchronized 快多少; 可以确定的原则是: volatile 变量读操作的性能消耗与普通变量几乎没有什么差别, 但是写操作则可能会慢一点, 因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行; 不过即便如此, 大多数场景下 volatile 的总开销仍然要比锁低, 在 volatile 与锁中选择的唯一依据仅仅是 volatile 的语义能够满足使用场景的需求  
假定 T 表示一个线程, V 和 W 分别表示两个 volatile 型变量, 那么在进行 read, load, use, assign, store, write 操作时需要满足如下规则:
- 只有当线程 T 对变量 V 执行的前一个动作是 load 的时候, 线程 T 才能对变量 V 执行 use 动作; 并且, 只有当线程 T 对变量 V 执行的后一个动作是 use 的时候, 线程 T 才能对变量 V 执行 load 动作; 线程 T 对变量 V 的 use 动作可以认为是和线程 T 对变量 V 的 load, read 动作相关联的, 必须连续一起出现 (这条规则要求在工作内存中, 每次使用 V 前都必须先从主内存刷新最新的值, 用于保证能看见其他线程对变量 V 所做的修改后的值)
- 只有当线程 T 对变量 V 执行的前一个动作是 assign 的时候, 线程 T 才能对变量 V 执行 storez 动作, 并且, 只有当线程 T 对变量 V 执行的后一个动作是 store 的时候, 线程 T 才能对变量 V 执行 assign 动作; 线程 T 对变量 V 的 assign 动作可以认为是和线程 T 对变量 V 的 store, write 动作相关联, 必须连续一起出现 (这条规则要求在工作内存中, 每次修改 V 后都必须立刻同步会主内存中, 用于保证其他线程可以看到自己对变量 V 所做的修改)
- 假定动作 A 是线程 T 对变量 V 实施的 use 或 assign 动作, 假定动作 F 是和动作 A 相关联的 load 或 store 动作, 假定动作 P 是和动作 F 相应的对变量 V 的 read 或 assign 动作, 假定动作 G 是和动作 B 相关联的 load 或 store 动作, 假定动作 Q 是和动作 G 相应的对变量 W 的 read 或 write 动作; 如果 A 先于 B, 那么 P 先于 Q (这条规则要求 volatile 修饰的变量不会被指令重排序优化, 保证代码的执行顺序与程序顺序相同)

##### 对于 long 和 double 型变量的特殊规则
Java 内存模型要求 lock, unlock, read, load, use, assign, store, write 这 8 个操作都具有原子性, 但是对于 64 位的数据类型 (long 和 double), 在模型中定义了一条相对宽松的规定: 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行, 即允许虚拟机实现选择可以不保证 64 位数据类型的 read, load, store, write 这四个操作的原子性, 这点就是所谓的 long 和 double 的非原子协定 (Nonatomic Treatment of double and long Variables)  
如果有多个线程共享一个并未声明为 volatile 的 long 或 double 类型的变量, 并且同时对它们进行读取和修改操作, 那么某些线程可能会读取到一个既非原值, 也不是其他线程修改的值的代表了 "半个变量" 的数值  
这种读取到 "半个变量" 的情况非常罕见 (在目前的商用 Java 虚拟机中不会出现), 因为 Java 内存模型虽然允许 Java 虚拟机不把 long 和 double 变量的读写实现为原子操作, 但是允许虚拟机选择把这些操作实现为具有原子性的操作, 而且强烈建议虚拟机这样实现, 所以在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile

##### 原子性, 可见性, 有序性
Java 内存模型是围绕着在并发过程中如何处理原子性, 可见性, 有序性这 3 个特性建立的

###### 原子性 (Atomicity)
由 Java 内存模型来直接保证的原子性变量操作包括 read, laod, use, assign, store, write, 大致可以认为基本数据类型的访问读写是具备原子性的; 如果应用场景需要一个更大范围的原子性保证, Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求, 尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用, 但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作, 这两个字节指令反映到 Java 代码中就是同步块 --- synchronized 关键字, 因此在 synchronized 块之间的操作也具备原子性

###### 可见性 (Visibility)
可见性是指当一个线程修改了共享变量的值, 其他线程能够立即得知这个修改; Java 内存模型是通过在变量修改后将新值同步回主内存, 在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的; 无论是普通变量还是 volatile 变量都是如此, 普通变量与 volatile 变量的区别就是, volatile 的特殊规则保证了新值能立即同步到主内存, 以及每次使用前立即从主内存刷新; 因此可以说 volatile 保证了多线程操作时变量的可见性, 而普通变量则不能保证这一点  
除了 volatile 之外, synchronized 和 final 也可以实现可见性; 同步块的可见性是由 "对一个变量执行 unlock 操作之前, 必须先把此变量同步会主内存中 (store 和 write 操作)" 这条规则获得的; 而 final 关键字的可见性是指: 被 final 修饰的字段在构造器中一旦初始化完成, 并且构造器没有把 "this" 的引用传递出去 (this 引用逃逸是一件很危险的事, 其他线程有可能通过这个引用访问到了 "初始化了一半" 的对象), 那在其他线程中就能看见 final 字段的值

###### 有序性 (Ordering)
Java 程序中天然的有序性可以总结为一句话: 如果在本线程内观察, 所有的操作都是有序的; 如果在一个线程中观察另一个线程, 所有的操作都是无序的; 前半句是指 "线程内表现为串行语义", 后半句是指 "指令重排序" 现象和 "工作内存与主内存同步延迟" 现象  
Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性, volatile 关键字本身就包含了禁止指令重排序的语义, 而 synchronized 则是由 "一个变量在同一时刻只允许一条线程对其进行 lock 操作" 这条规则获得的, 这条规则决定了持有同一个锁的两个同步块只能串行地进入

##### 先行发生原则
