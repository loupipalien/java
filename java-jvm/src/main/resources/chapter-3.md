### Java 内存区域与内存溢出异常
Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的 "高墙", 墙外面的人想进去, 墙里面的人却想出来

#### 概述
垃圾收集 (Garbage Collection, GC) 的历史比 Java 久远, 1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言, 人们认为 GC 需要完成的有以下三件事
- 哪些内存需要回收?
- 什么时候回收?
- 如何回收?

第 2 章中介绍了 Java 内存运行时区域的各个部分, 其中程序计数器, 虚拟机栈, 本地方法栈三个区域随着线程而生, 随着线程而灭; 栈中的每一个栈帧中分配多少内存基本上是在类结构确定时就已知的, 因此这几个区域的内存分配和回收都具有确定性, 因此不需要过多的考虑回收的问题; 而 Java 堆和方法区则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支需要的内存也可能不一样, 我们只有在程序运行期间才能知道会创建哪些对象; 这部分的内存的分配和回收是动态的, 垃圾收集器关注的是这部分内存  

#### 对象已死吗?
在堆里存放着 Java 世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收之前, 第一件事情就是要确定这些对象之中还有哪些 "存活" 着, 哪些已经 "死去" (即不可能再被任何途径使用的对象)

##### 引用计数算法
判断对象是否存活的算法是这样的: 给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一, 当引用失效时, 计数器值就减一, 任何时刻计数器为 0 的对象就是不可能再被使用的; 微软的 COM (Component Object Model) 技术, 使用 ActionScript 的 FlashPlayer, Python 语言和在游戏脚本领域应用的 Squirrel 中都使用了引用计数算法进行内存管理; 但是主流 Java 虚拟机里没有用引用计数算法, 其中最主要的原因是它很难解决对象之间相互循环引用的问题  

##### 可达性分析算法
在主流的商用程序语言 (Java, C#, Lisp等) 的主流实现中, 都是通过可达性分析来判断对象是否存活的; 这个算法的基本思想就是通过一系列的称为 "GC Roots" 的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为引用链 (Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的  
在 Java 语言中可作为 GC Roots 的对象包括以下几种
- 虚拟机栈 (栈帧中的本地变量表) 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

##### 再谈引用
在 JDK 1.2 之前, Java 中引用的定义很传统: 如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址, 就称这块内存代表着一个引用; 这种定义很纯粹但也很狭隘, 一个对在这种定义下只有被引用和没有被引用两种状态, 对于如何描述一些 "食之无味, 弃之可惜" 的对象就显得无能为力; 例如希望描述这样一类对象: 当内存空间还足够时, 则能保留在内存之中; 如果内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃这些对象; 很多缓存功能符合这样的场景  
在 JDK 1.2 之后, Java 对引用概念进行了扩充, 将引用分为强引用 (Strong Reference), 软引用 (Soft Reference), 弱引用 (Weak Reference), 虚引用 (Phantom Reference) 四种
- 强引用就是指代码中普遍存在的, 类似 "Object obj = new Object()" 这类引用, 只要强引用还在, 垃圾收集器永远不会回收掉被引用的对象
- 软引用是用来描述一些还有用但并非必需的对象; 对于软引用关联的对象, 在系统将要发生内存溢出异常之前, 会将这些对象列入回收范围之中进行第二次回收, 如果这次回收还没有足够的内存, 才会抛出内存溢出异常; 在 JDK 1.2 之后, 提供了 SoftReference 类来实现软引用
- 弱引用也是用来描述非必需对象的, 但是它比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾回收发生之前; 当垃圾收集器开始工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象; 在 JDK 1.2 之后, 提供了 WeakReference 类来实现弱引用
- 虚引用也称为幽灵引用或幻影引用, 它是最弱的一种引用关系; 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例; 为对象设置一个虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知; 在 JDK 1.2 之后, 提供了 PhantomReference 类来实现虚引用

##### 生存还是死亡
即使在可达性分析算法中不可达的对象, 也并非是 "非死不可" 的, 要宣告一个对象死亡至少要经历两次标记过程: 如果对象在进行可达性分析后发现没有与 GC Roots 相连的引用链, 那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行 finalize() 方法; 当对象没有覆盖 finalize() 方法, 或者 finalize() 方法已经被虚拟机调用过了, 虚拟机将这两种情况都视为 "没有必要执行"  
如果这个对象被判定为有必要执行 finalize() 方法, 那么这个对象将会被防止在一个叫做 F-Queue 的队列中, 并在稍后由一个虚拟机自动建立的, 低优先级的 Finalizer 线程区执行; 这里的执行是指虚拟机会触发 finalize() 方法, 但并不承诺会等待它运行结束, 这样做的原因是, 如果一个对象在 finalize() 方法中执行缓慢, 或者发生了死循环, 将很可能会导致 F-Queue 队列中其他对象永远处于等待, 甚至导致整个内存回收系统奔溃; finalize() 方法是对象逃脱死亡命运的最后一次机会, 稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记, 如果对象在 finalize() 中成功拯救了自己 --- 只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将会被移出 "即将回收" 集合; 如果这时还未逃脱, 那基本上它就真的被回收了

##### 回收方法区
Java 虚拟机规范中可以不要求在方法区实现垃圾收集, 并且在方法区中进行垃圾收集的 "性价比" 较低: 在堆中, 尤其在新生代中, 常规应用进行一次垃圾收集一般可以回收 70% ~ 90% 的空间, 而在方法区 (HotSpot 的永久代) 的垃圾收集效率远低于此  
永久代的垃圾收集主要回收两部分内容: 废弃常量和无用的类; 回收废弃常量与回收 Java 堆中的对象类似, 当没有地方引用常量, 如果发生内存回收, 而且有必要的话就会被回收; 判定一个常量是否时 "废弃常量" 比较简单, 而要判定一个类是否时 "无用的类" 的条件则相对苛刻很多, 类要同时满足以下三个条件才算是 "无用的类"
- 该类所有的实例都已经被回收, 也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法

虚拟机对满足以上三个条件的无用的类可以进行回收, 但不像对象那样不用了就回收; 是否对类进行回收, HotSpot 虚拟机提供了 -Xnoclassgc 参数控制

#### 垃圾收集算法
由于各个平台虚拟机操作内存的方法各不相同, 以下只介绍算法的思想及发展过程

##### 标记 - 清除算法
最基础的收集算法是 "标记-清除" (Mark-Sweep) 算法, 算法分为 "标记" 和 "清除" 两个阶段: 首先标记处所有需要回收的对象, 在标记完成后统一回收所有被标记的对象; 此算法的不足主要有两个: 一是效率问题, 标记和清除两个过程的效率都不高; 另一个是空间问题, 标记清除之后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时, 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

##### 复制算法
为了解决效率问题, 复制算法出现了; 它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块; 当这一块的内存使用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉; 这样每次都对整个半区进行内存回收, 内存分配时也就不用考虑内存碎片等复杂情况, 只是这样的空间代价较高  
现在商业虚拟机都采用这种算法来回收新生代, IBM 公司研究表明新生代中 98% 的对象都是 "朝生夕死" 的, 所以不需要按照 1 : 1 的比例划分内存空间, 而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间; 每次使用 Eden 空间和其中一块 Survivor 空间, 当回收时, 将 Eden 和 Survivor 中还存活的对象一次性的复制到另外一块 Survivor 空间上, 最后清理掉 Eden 和之前使用过的 Survivor 空间; HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8 : 1; 虚拟机没有办法保证每次回收都只有不多于 10% 的对象存活, 当 Survivor 空间不够用时, 需要依赖其他内存 (这里指老年代) 进行分配担保 (Handle Promotion); 即另外一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时, 这些对象将直接通过分配担保机制进入老年代

##### 标记 - 整理算法
复制收集算法在对象存活率较高时就要进行较多的复制操作, 效率会变低; 更关键的是, 如果不像浪费 50% 的空间, 就需要有额外的空间进行分配担保, 以应对被使用的内存中对象 100% 存活的极端情况, 所以在老年代一般不能直接使用这种算法  
根据老年代的特点提出了 "标记 - 整理" (Mark-Compact) 算法, 标记过程和 "标记 - 清除" 算法一样, 但后续步骤不是直接可回收对象进行清理, 而是让所有存活的对象向一端移动, 然后直接清理掉端边界以外的内存

##### 分代收集算法
当前商业虚拟机的垃圾收集都采用 "分代收集" (Generational Collection) 算法, 这种算法只是根据对象存活周期的不同将内存划分为几块; 一般是把 Java 堆分为新生代和老年代, 在新生代采用复制算法, 在老年代采用 "标记 - 清理" 或 "标记 - 整理" 算法

#### HotSpot 的算法实现
以上介绍了对象存活判定算法和垃圾收集算法, HotSpot 在实现这些算法时必须对算法的执行效率有严格的考量, 才能保证虚拟机高效运行

##### 枚举根节点
从可达性分析中自 GC Roots 节点找引用链, 可作为 GC Roots 的节点主要在全局性的引用和执行上下文中, 但很多应用仅方法区就有数百兆, 如果要逐个检查所用引用, 必然会耗费很多时间  
另外, 可达性分析对执行时间敏感还体现在 GC 的停顿上, 因为这项分析工作必须在一个能确保一致性的快照中进行, 这里的一致性的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上, 不可以出现分析过程中对象引用关系还在不断变化的情况; 如果这一点不能满足分析结果则无准确性可言; 这一点是导致 GC 进行时必须停顿所有 Java 执行线程 (传说中的 Stop The World) 的其中一个重要原因, 即使是在号称 (几乎) 不会发生停顿的 CMS 收集器中, 枚举根节点时也是必须要停顿的  
目前的主流 Java 虚拟机使用的都是准确式 GC, 即所有执行系统停顿下来后, 并不需要一个不漏的检查湾所有执行上下文和全局的引用位置; HotSpot 使用一组称为 OopMap 的数据结构来达到这个目的, 在类加载完成的时候, HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来, 这样 GC 在扫描时就可以直接得知这些信息了  

##### 安全点
在 OopMap 的协助下, HotSpot 可以完成快速准确的 GC Roots 枚举; HotSpot 并没有为每条指令都生存 OopMap, 只是在 "特定的位置" 记录了这些信息, 这些位置称为安全点 (Safepoint), 即程序执行只有到了安全点才能停顿下来开始 GC; 安全点的选定既不能太少以致于让 GC 等待时间太长, 也不能过于频繁增大运行负荷; 所以基本上是以程序 "是否具有让程序长时间执行的特征" 为标准选定的  
对于安全点另一个需要考虑的问题是如何在 GC 发生时让所有线程都跑到最近的安全点上停顿下来; 这里有两种方案选择
- 抢先式中断: 抢先式中断不需要线程的执行代码主动去配合, 在 GC 发生时, 首先把所有线程全部中断, 如果发现线程中断的地方不在安全点上, 就恢复线程让其跑到安全点上; 现在几乎没有虚拟机采用这种方式
- 主动式中断: 主动式中断的思想是当 GC 需要中断线程时, 不直接对线程操作, 仅仅简单的设置一个标志, 各个线程执行时主动去轮询这个标志, 发现中断标志时自己挂起, 轮询标志的地方和安全点是重合的

##### 安全区
使用安全点保证了程序在执行时, 在不太长的时间内就会遇到可进入的 GC 安全点; 但是程序在不执行 (没有分配到 CPU 时间) 的时候, 这些线程无法响应 JVM 的中断请求, 走到安全点挂起, JVM 也不可能等待线程重新被分配时间; 这种情况就需要安全区来解决  
安全区是指在一段代码片段中, 引用关系不会发生变化; 在这个区域内的任意地方开始 GC 都是安全的, 也可以把安全区看成是被扩展的安全点

#### 垃圾收集器
