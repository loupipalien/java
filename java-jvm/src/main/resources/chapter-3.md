### Java 内存区域与内存溢出异常
Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的 "高墙", 墙外面的人想进去, 墙里面的人却想出来

#### 概述
垃圾收集 (Garbage Collection, GC) 的历史比 Java 久远, 1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言, 人们认为 GC 需要完成的有以下三件事
- 哪些内存需要回收?
- 什么时候回收?
- 如何回收?

第 2 章中介绍了 Java 内存运行时区域的各个部分, 其中程序计数器, 虚拟机栈, 本地方法栈三个区域随着线程而生, 随着线程而灭; 栈中的每一个栈帧中分配多少内存基本上是在类结构确定时就已知的, 因此这几个区域的内存分配和回收都具有确定性, 因此不需要过多的考虑回收的问题; 而 Java 堆和方法区则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支需要的内存也可能不一样, 我们只有在程序运行期间才能知道会创建哪些对象; 这部分的内存的分配和回收是动态的, 垃圾收集器关注的是这部分内存  

#### 对象已死吗?
在堆里存放着 Java 世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收之前, 第一件事情就是要确定这些对象之中还有哪些 "存活" 着, 哪些已经 "死去" (即不可能再被任何途径使用的对象)

##### 引用计数算法
判断对象是否存活的算法是这样的: 给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一, 当引用失效时, 计数器值就减一, 任何时刻计数器为 0 的对象就是不可能再被使用的; 微软的 COM (Component Object Model) 技术, 使用 ActionScript 的 FlashPlayer, Python 语言和在游戏脚本领域应用的 Squirrel 中都使用了引用计数算法进行内存管理; 但是主流 Java 虚拟机里没有用引用计数算法, 其中最主要的原因是它很难解决对象之间相互循环引用的问题  

##### 可达性分析算法
在主流的商用程序语言 (Java, C#, Lisp等) 的主流实现中, 都是通过可达性分析来判断对象是否存活的; 这个算法的基本思想就是通过一系列的称为 "GC Roots" 的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为引用链 (Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的  
在 Java 语言中可作为 GC Roots 的对象包括以下几种
- 虚拟机栈 (栈帧中的本地变量表) 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

##### 再谈引用
在 JDK 1.2 之前, Java 中引用的定义很传统: 如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址, 就称这块内存代表着一个引用; 这种定义很纯粹但也很狭隘, 一个对在这种定义下只有被引用和没有被引用两种状态, 对于如何描述一些 "食之无味, 弃之可惜" 的对象就显得无能为力; 例如希望描述这样一类对象: 当内存空间还足够时, 则能保留在内存之中; 如果内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃这些对象; 很多缓存功能符合这样的场景  
在 JDK 1.2 之后, Java 对引用概念进行了扩充, 将引用分为强引用 (Strong Reference), 软引用 (Soft Reference), 弱引用 (Weak Reference), 虚引用 (Phantom Reference) 四种
- 强引用就是指代码中普遍存在的, 类似 "Object obj = new Object()" 这类引用, 只要强引用还在, 垃圾收集器永远不会回收掉被引用的对象
- 软引用是用来描述一些还有用但并非必需的对象; 对于软引用关联的对象, 在系统将要发生内存溢出异常之前, 会将这些对象列入回收范围之中进行第二次回收, 如果这次回收还没有足够的内存, 才会抛出内存溢出异常; 在 JDK 1.2 之后, 提供了 SoftReference 类来实现软引用
- 弱引用也是用来描述非必需对象的, 但是它比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾回收发生之前; 当垃圾收集器开始工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象; 在 JDK 1.2 之后, 提供了 WeakReference 类来实现弱引用
- 虚引用也称为幽灵引用或幻影引用, 它是最弱的一种引用关系; 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例; 为对象设置一个虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知; 在 JDK 1.2 之后, 提供了 PhantomReference 类来实现虚引用

##### 生存还是死亡
即使在可达性分析算法中不可达的对象, 也并非是 "非死不可" 的, 要宣告一个对象死亡至少要经历两次标记过程: 如果对象在进行可达性分析后发现没有与 GC Roots 相连的引用链, 那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行 finalize() 方法; 当对象没有覆盖 finalize() 方法, 或者 finalize() 方法已经被虚拟机调用过了, 虚拟机将这两种情况都视为 "没有必要执行"  
如果这个对象被判定为有必要执行 finalize() 方法, 那么这个对象将会被防止在一个叫做 F-Queue 的队列中, 并在稍后由一个虚拟机自动建立的, 低优先级的 Finalizer 线程区执行; 这里的执行是指虚拟机会触发 finalize() 方法, 但并不承诺会等待它运行结束, 这样做的原因是, 如果一个对象在 finalize() 方法中执行缓慢, 或者发生了死循环, 将很可能会导致 F-Queue 队列中其他对象永远处于等待, 甚至导致整个内存回收系统奔溃; finalize() 方法是对象逃脱死亡命运的最后一次机会, 稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记, 如果对象在 finalize() 中成功拯救了自己 --- 只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将会被移出 "即将回收" 集合; 如果这时还未逃脱, 那基本上它就真的被回收了

##### 回收方法区
Java 虚拟机规范中可以不要求在方法区实现垃圾收集, 并且在方法区中进行垃圾收集的 "性价比" 较低: 在堆中, 尤其在新生代中, 常规应用进行一次垃圾收集一般可以回收 70% ~ 90% 的空间, 而在方法区 (HotSpot 的永久代) 的垃圾收集效率远低于此  
永久代的垃圾收集主要回收两部分内容: 废弃常量和无用的类; 回收废弃常量与回收 Java 堆中的对象类似, 当没有地方引用常量, 如果发生内存回收, 而且有必要的话就会被回收; 判定一个常量是否时 "废弃常量" 比较简单, 而要判定一个类是否时 "无用的类" 的条件则相对苛刻很多, 类要同时满足以下三个条件才算是 "无用的类"
- 该类所有的实例都已经被回收, 也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法

虚拟机对满足以上三个条件的无用的类可以进行回收, 但不像对象那样不用了就回收; 是否对类进行回收, HotSpot 虚拟机提供了 -Xnoclassgc 参数控制

#### 垃圾收集算法
由于各个平台虚拟机操作内存的方法各不相同, 以下只介绍算法的思想及发展过程

##### 标记 - 清除算法
最基础的收集算法是 "标记-清除" (Mark-Sweep) 算法, 算法分为 "标记" 和 "清除" 两个阶段: 首先标记处所有需要回收的对象, 在标记完成后统一回收所有被标记的对象; 此算法的不足主要有两个: 一是效率问题, 标记和清除两个过程的效率都不高; 另一个是空间问题, 标记清除之后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时, 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

##### 复制算法
为了解决效率问题, 复制算法出现了; 它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块; 当这一块的内存使用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉; 这样每次都对整个半区进行内存回收, 内存分配时也就不用考虑内存碎片等复杂情况, 只是这样的空间代价较高  
现在商业虚拟机都采用这种算法来回收新生代, IBM 公司研究表明新生代中 98% 的对象都是 "朝生夕死" 的, 所以不需要按照 1 : 1 的比例划分内存空间, 而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间; 每次使用 Eden 空间和其中一块 Survivor 空间, 当回收时, 将 Eden 和 Survivor 中还存活的对象一次性的复制到另外一块 Survivor 空间上, 最后清理掉 Eden 和之前使用过的 Survivor 空间; HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8 : 1; 虚拟机没有办法保证每次回收都只有不多于 10% 的对象存活, 当 Survivor 空间不够用时, 需要依赖其他内存 (这里指老年代) 进行分配担保 (Handle Promotion); 即另外一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时, 这些对象将直接通过分配担保机制进入老年代

##### 标记 - 整理算法
复制收集算法在对象存活率较高时就要进行较多的复制操作, 效率会变低; 更关键的是, 如果不像浪费 50% 的空间, 就需要有额外的空间进行分配担保, 以应对被使用的内存中对象 100% 存活的极端情况, 所以在老年代一般不能直接使用这种算法  
根据老年代的特点提出了 "标记 - 整理" (Mark-Compact) 算法, 标记过程和 "标记 - 清除" 算法一样, 但后续步骤不是直接可回收对象进行清理, 而是让所有存活的对象向一端移动, 然后直接清理掉端边界以外的内存

##### 分代收集算法
当前商业虚拟机的垃圾收集都采用 "分代收集" (Generational Collection) 算法, 这种算法只是根据对象存活周期的不同将内存划分为几块; 一般是把 Java 堆分为新生代和老年代, 在新生代采用复制算法, 在老年代采用 "标记 - 清理" 或 "标记 - 整理" 算法

#### HotSpot 的算法实现
