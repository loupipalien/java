### Java 内存区域与内存溢出异常
Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的 "高墙", 墙外面的人想进去, 墙里面的人却想出来

#### 概述
垃圾收集 (Garbage Collection, GC) 的历史比 Java 久远, 1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言, 人们认为 GC 需要完成的有以下三件事
- 哪些内存需要回收?
- 什么时候回收?
- 如何回收?

第 2 章中介绍了 Java 内存运行时区域的各个部分, 其中程序计数器, 虚拟机栈, 本地方法栈三个区域随着线程而生, 随着线程而灭; 栈中的每一个栈帧中分配多少内存基本上是在类结构确定时就已知的, 因此这几个区域的内存分配和回收都具有确定性, 因此不需要过多的考虑回收的问题; 而 Java 堆和方法区则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支需要的内存也可能不一样, 我们只有在程序运行期间才能知道会创建哪些对象; 这部分的内存的分配和回收是动态的, 垃圾收集器关注的是这部分内存  

#### 对象已死吗?
在堆里存放着 Java 世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收之前, 第一件事情就是要确定这些对象之中还有哪些 "存活" 着, 哪些已经 "死去" (即不可能再被任何途径使用的对象)

##### 引用计数算法
判断对象是否存活的算法是这样的: 给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一, 当引用失效时, 计数器值就减一, 任何时刻计数器为 0 的对象就是不可能再被使用的; 微软的 COM (Component Object Model) 技术, 使用 ActionScript 的 FlashPlayer, Python 语言和在游戏脚本领域应用的 Squirrel 中都使用了引用计数算法进行内存管理; 但是主流 Java 虚拟机里没有用引用计数算法, 其中最主要的原因是它很难解决对象之间相互循环引用的问题  

##### 可达性分析算法
在主流的商用程序语言 (Java, C#, Lisp等) 的主流实现中, 都是通过可达性分析来判断对象是否存活的; 这个算法的基本思想就是通过一系列的称为 "GC Roots" 的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为引用链 (Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的  
在 Java 语言中可作为 GC Roots 的对象包括以下几种
- 虚拟机栈 (栈帧中的本地变量表) 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

##### 再谈引用
在 JDK 1.2 之前, Java 中引用的定义很传统: 如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址, 就称这块内存代表着一个引用; 这种定义很纯粹但也很狭隘, 一个对在这种定义下只有被引用和没有被引用两种状态, 对于如何描述一些 "食之无味, 弃之可惜" 的对象就显得无能为力; 例如希望描述这样一类对象: 当内存空间还足够时, 则能保留在内存之中; 如果内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃这些对象; 很多缓存功能符合这样的场景  
在 JDK 1.2 之后, Java 对引用概念进行了扩充, 将引用分为强引用 (Strong Reference), 软引用 (Soft Reference), 弱引用 (Weak Reference), 虚引用 (Phantom Reference) 四种
- 强引用就是指代码中普遍存在的, 类似 "Object obj = new Object()" 这类引用, 只要强引用还在, 垃圾收集器永远不会回收掉被引用的对象
- 软引用是用来描述一些还有用但并非必需的对象; 对于软引用关联的对象, 在系统将要发生内存溢出异常之前, 会将这些对象列入回收范围之中进行第二次回收, 如果这次回收还没有足够的内存, 才会抛出内存溢出异常; 在 JDK 1.2 之后, 提供了 SoftReference 类来实现软引用
- 弱引用也是用来描述非必需对象的, 但是它比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾回收发生之前; 当垃圾收集器开始工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象; 在 JDK 1.2 之后, 提供了 WeakReference 类来实现弱引用
- 虚引用也称为幽灵引用或幻影引用, 它是最弱的一种引用关系; 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例; 为对象设置一个虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知; 在 JDK 1.2 之后, 提供了 PhantomReference 类来实现虚引用
