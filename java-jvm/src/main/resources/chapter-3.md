### Java 内存区域与内存溢出异常
Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的 "高墙", 墙外面的人想进去, 墙里面的人却想出来

#### 概述
垃圾收集 (Garbage Collection, GC) 的历史比 Java 久远, 1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言, 人们认为 GC 需要完成的有以下三件事
- 哪些内存需要回收?
- 什么时候回收?
- 如何回收?

第 2 章中介绍了 Java 内存运行时区域的各个部分, 其中程序计数器, 虚拟机栈, 本地方法栈三个区域随着线程而生, 随着线程而灭; 栈中的每一个栈帧中分配多少内存基本上是在类结构确定时就已知的, 因此这几个区域的内存分配和回收都具有确定性, 因此不需要过多的考虑回收的问题; 而 Java 堆和方法区则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支需要的内存也可能不一样, 我们只有在程序运行期间才能知道会创建哪些对象; 这部分的内存的分配和回收是动态的, 垃圾收集器关注的是这部分内存  

#### 对象已死吗?
在堆里存放着 Java 世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收之前, 第一件事情就是要确定这些对象之中还有哪些 "存活" 着, 哪些已经 "死去" (即不可能再被任何途径使用的对象)

##### 引用计数算法
判断对象是否存活的算法是这样的: 给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一, 当引用失效时, 计数器值就减一, 任何时刻计数器为 0 的对象就是不可能再被使用的; 微软的 COM (Component Object Model) 技术, 使用 ActionScript 的 FlashPlayer, Python 语言和在游戏脚本领域应用的 Squirrel 中都使用了引用计数算法进行内存管理; 但是主流 Java 虚拟机里没有用引用计数算法, 其中最主要的原因是它很难解决对象之间相互循环引用的问题  

##### 可达性分析算法
在主流的商用程序语言 (Java, C#, Lisp等) 的主流实现中, 都是通过可达性分析来判断对象是否存活的; 这个算法的基本思想就是通过一系列的称为 "GC Roots" 的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为引用链 (Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的  
在 Java 语言中可作为 GC Roots 的对象包括以下几种
- 虚拟机栈 (栈帧中的本地变量表) 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

##### 再谈引用
在 JDK 1.2 之前, Java 中引用的定义很传统: 如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址, 就称这块内存代表着一个引用; 这种定义很纯粹但也很狭隘, 一个对在这种定义下只有被引用和没有被引用两种状态, 对于如何描述一些 "食之无味, 弃之可惜" 的对象就显得无能为力; 例如希望描述这样一类对象: 当内存空间还足够时, 则能保留在内存之中; 如果内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃这些对象; 很多缓存功能符合这样的场景  
在 JDK 1.2 之后, Java 对引用概念进行了扩充, 将引用分为强引用 (Strong Reference), 软引用 (Soft Reference), 弱引用 (Weak Reference), 虚引用 (Phantom Reference) 四种
- 强引用就是指代码中普遍存在的, 类似 "Object obj = new Object()" 这类引用, 只要强引用还在, 垃圾收集器永远不会回收掉被引用的对象
- 软引用是用来描述一些还有用但并非必需的对象; 对于软引用关联的对象, 在系统将要发生内存溢出异常之前, 会将这些对象列入回收范围之中进行第二次回收, 如果这次回收还没有足够的内存, 才会抛出内存溢出异常; 在 JDK 1.2 之后, 提供了 SoftReference 类来实现软引用
- 弱引用也是用来描述非必需对象的, 但是它比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾回收发生之前; 当垃圾收集器开始工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象; 在 JDK 1.2 之后, 提供了 WeakReference 类来实现弱引用
- 虚引用也称为幽灵引用或幻影引用, 它是最弱的一种引用关系; 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例; 为对象设置一个虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知; 在 JDK 1.2 之后, 提供了 PhantomReference 类来实现虚引用

##### 生存还是死亡
即使在可达性分析算法中不可达的对象, 也并非是 "非死不可" 的, 要宣告一个对象死亡至少要经历两次标记过程: 如果对象在进行可达性分析后发现没有与 GC Roots 相连的引用链, 那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行 finalize() 方法; 当对象没有覆盖 finalize() 方法, 或者 finalize() 方法已经被虚拟机调用过了, 虚拟机将这两种情况都视为 "没有必要执行"  
如果这个对象被判定为有必要执行 finalize() 方法, 那么这个对象将会被防止在一个叫做 F-Queue 的队列中, 并在稍后由一个虚拟机自动建立的, 低优先级的 Finalizer 线程区执行; 这里的执行是指虚拟机会触发 finalize() 方法, 但并不承诺会等待它运行结束, 这样做的原因是, 如果一个对象在 finalize() 方法中执行缓慢, 或者发生了死循环, 将很可能会导致 F-Queue 队列中其他对象永远处于等待, 甚至导致整个内存回收系统奔溃; finalize() 方法是对象逃脱死亡命运的最后一次机会, 稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记, 如果对象在 finalize() 中成功拯救了自己 --- 只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将会被移出 "即将回收" 集合; 如果这时还未逃脱, 那基本上它就真的被回收了

##### 回收方法区
Java 虚拟机规范中可以不要求在方法区实现垃圾收集, 并且在方法区中进行垃圾收集的 "性价比" 较低: 在堆中, 尤其在新生代中, 常规应用进行一次垃圾收集一般可以回收 70% ~ 90% 的空间, 而在方法区 (HotSpot 的永久代) 的垃圾收集效率远低于此  
永久代的垃圾收集主要回收两部分内容: 废弃常量和无用的类; 回收废弃常量与回收 Java 堆中的对象类似, 当没有地方引用常量, 如果发生内存回收, 而且有必要的话就会被回收; 判定一个常量是否时 "废弃常量" 比较简单, 而要判定一个类是否时 "无用的类" 的条件则相对苛刻很多, 类要同时满足以下三个条件才算是 "无用的类"
- 该类所有的实例都已经被回收, 也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法

虚拟机对满足以上三个条件的无用的类可以进行回收, 但不像对象那样不用了就回收; 是否对类进行回收, HotSpot 虚拟机提供了 -Xnoclassgc 参数控制

#### 垃圾收集算法
由于各个平台虚拟机操作内存的方法各不相同, 以下只介绍算法的思想及发展过程

##### 标记 - 清除算法
最基础的收集算法是 "标记-清除" (Mark-Sweep) 算法, 算法分为 "标记" 和 "清除" 两个阶段: 首先标记处所有需要回收的对象, 在标记完成后统一回收所有被标记的对象; 此算法的不足主要有两个: 一是效率问题, 标记和清除两个过程的效率都不高; 另一个是空间问题, 标记清除之后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时, 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

##### 复制算法
为了解决效率问题, 复制算法出现了; 它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块; 当这一块的内存使用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉; 这样每次都对整个半区进行内存回收, 内存分配时也就不用考虑内存碎片等复杂情况, 只是这样的空间代价较高  
现在商业虚拟机都采用这种算法来回收新生代, IBM 公司研究表明新生代中 98% 的对象都是 "朝生夕死" 的, 所以不需要按照 1 : 1 的比例划分内存空间, 而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间; 每次使用 Eden 空间和其中一块 Survivor 空间, 当回收时, 将 Eden 和 Survivor 中还存活的对象一次性的复制到另外一块 Survivor 空间上, 最后清理掉 Eden 和之前使用过的 Survivor 空间; HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8 : 1; 虚拟机没有办法保证每次回收都只有不多于 10% 的对象存活, 当 Survivor 空间不够用时, 需要依赖其他内存 (这里指老年代) 进行分配担保 (Handle Promotion); 即另外一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时, 这些对象将直接通过分配担保机制进入老年代

##### 标记 - 整理算法
复制收集算法在对象存活率较高时就要进行较多的复制操作, 效率会变低; 更关键的是, 如果不像浪费 50% 的空间, 就需要有额外的空间进行分配担保, 以应对被使用的内存中对象 100% 存活的极端情况, 所以在老年代一般不能直接使用这种算法  
根据老年代的特点提出了 "标记 - 整理" (Mark-Compact) 算法, 标记过程和 "标记 - 清除" 算法一样, 但后续步骤不是直接可回收对象进行清理, 而是让所有存活的对象向一端移动, 然后直接清理掉端边界以外的内存

##### 分代收集算法
当前商业虚拟机的垃圾收集都采用 "分代收集" (Generational Collection) 算法, 这种算法只是根据对象存活周期的不同将内存划分为几块; 一般是把 Java 堆分为新生代和老年代, 在新生代采用复制算法, 在老年代采用 "标记 - 清理" 或 "标记 - 整理" 算法

#### HotSpot 的算法实现
以上介绍了对象存活判定算法和垃圾收集算法, HotSpot 在实现这些算法时必须对算法的执行效率有严格的考量, 才能保证虚拟机高效运行

##### 枚举根节点
从可达性分析中自 GC Roots 节点找引用链, 可作为 GC Roots 的节点主要在全局性的引用和执行上下文中, 但很多应用仅方法区就有数百兆, 如果要逐个检查所用引用, 必然会耗费很多时间  
另外, 可达性分析对执行时间敏感还体现在 GC 的停顿上, 因为这项分析工作必须在一个能确保一致性的快照中进行, 这里的一致性的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上, 不可以出现分析过程中对象引用关系还在不断变化的情况; 如果这一点不能满足分析结果则无准确性可言; 这一点是导致 GC 进行时必须停顿所有 Java 执行线程 (传说中的 Stop The World) 的其中一个重要原因, 即使是在号称 (几乎) 不会发生停顿的 CMS 收集器中, 枚举根节点时也是必须要停顿的  
目前的主流 Java 虚拟机使用的都是准确式 GC, 即所有执行系统停顿下来后, 并不需要一个不漏的检查湾所有执行上下文和全局的引用位置; HotSpot 使用一组称为 OopMap 的数据结构来达到这个目的, 在类加载完成的时候, HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来, 这样 GC 在扫描时就可以直接得知这些信息了  

##### 安全点
在 OopMap 的协助下, HotSpot 可以完成快速准确的 GC Roots 枚举; HotSpot 并没有为每条指令都生存 OopMap, 只是在 "特定的位置" 记录了这些信息, 这些位置称为安全点 (Safepoint), 即程序执行只有到了安全点才能停顿下来开始 GC; 安全点的选定既不能太少以致于让 GC 等待时间太长, 也不能过于频繁增大运行负荷; 所以基本上是以程序 "是否具有让程序长时间执行的特征" 为标准选定的  
对于安全点另一个需要考虑的问题是如何在 GC 发生时让所有线程都跑到最近的安全点上停顿下来; 这里有两种方案选择
- 抢先式中断: 抢先式中断不需要线程的执行代码主动去配合, 在 GC 发生时, 首先把所有线程全部中断, 如果发现线程中断的地方不在安全点上, 就恢复线程让其跑到安全点上; 现在几乎没有虚拟机采用这种方式
- 主动式中断: 主动式中断的思想是当 GC 需要中断线程时, 不直接对线程操作, 仅仅简单的设置一个标志, 各个线程执行时主动去轮询这个标志, 发现中断标志时自己挂起, 轮询标志的地方和安全点是重合的

##### 安全区
使用安全点保证了程序在执行时, 在不太长的时间内就会遇到可进入的 GC 安全点; 但是程序在不执行 (没有分配到 CPU 时间) 的时候, 这些线程无法响应 JVM 的中断请求, 走到安全点挂起, JVM 也不可能等待线程重新被分配时间; 这种情况就需要安全区来解决  
安全区是指在一段代码片段中, 引用关系不会发生变化; 在这个区域内的任意地方开始 GC 都是安全的, 也可以把安全区看成是被扩展的安全点

#### 垃圾收集器  
在介绍这些收集器各自特性之前, 需要明确的观点是: 虽然是对各个收集器进行比较, 但并非为了挑选出一个最好的收集器; 因为直到现在为止还没有最好的收集器出现, 更没有万能的收集器, 所以选择的是对具体应用最合适的收集器

##### Serial 收集器
Serial 收集器是最基本, 发展历史最悠久的收集器, 在 JDK 1.3.1 之前是虚拟机新生代收集的唯一选择; 此收集器是一个单线程收集器, 但它 "单线程" 的含义并不仅仅说明它只会使用一个 CPU 和一个收集线程去完成垃圾收集工作, 更重要的是它进行垃圾收集时, 必须暂停其他所有的工作线程, 直到收集完毕  
从 JDK 1.3 开始, 一直到现在最新的 JDK 1.7, HotSpot 虚拟机开发团队为消除或减少工作线程因为内存回收而导致停顿的努力一直在进行着; 从 Serial 收集器到 Parallel 收集器, 再到 Concurrent Mark Sweep (CMS) 乃至 GC 收集器的最前沿成果 Garbage First (G1) 收集器; 但实际上到目前为止, Serial 收集器仍然是虚拟机在 Client 模式下的默认的新生代收集器; 相对其他收集器的单线程比, Serial 收集器简单而高效, 对于限定的单个 CPU 环境来说 Serial 收集器是很好的选择

##### ParNew 收集器
ParNew 收集器是 Serial 收集器的多线程版本, 除了使用多条线程进行垃圾收集之外, 其余行为包括 Serial 收集器可用的所有控制参数 (例如: -XX:SurvivorRatio, -XX:PetenureSizeThreshold, -XX:HandlePromotionFailure 等), 收集算法, Stop The World, 对象分配规则, 回收策略和 Serial 收集器完全一样; 虽然与 Serial 收集器相比没有太多创新处, 但却是 Server 模式下的首选新生代收集器, 其中有一个与性能无关的但重要的原因, 除了 Serial 收集器外, 目前只有 ParNew 收集器能与 CMS 收集器配合工作; 在 JDK 1.5 时期推出了 CMS (Concurrent Mark Sweep) 收集器, 这款收集器第一次实现了让垃圾收集线程与用户线程同时工作  
不幸的是, CMS 作为老年代的收集器, 却无法和 JDK 1.4 中已存在的新生代收集器 Parallel Scavenge 配合工作, 所以在 JDK 1.5 中使用 CMS 收集老年代时, 新生代只能选择 ParNew 收集器或 Serial 收集器中的一个; ParNew 收集器也是使用 -XX:+UseConcMarkSweepGC 选项后的默认新生代收集器, 也可以使用 -XX: UseParNewGC 选项来强制指定它  
ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器有更好的效果, 但随着可使用的 CPU 数量的增加, 对于 GC 时系统资源的有效利用还是很有好处的; 它默认开启的收集线程数与 CPU 的数量相同, 在 CPU 非常多的环境下, 可以使用 -XX: ParallelGCThreads 参数来限制垃圾收集的线程数  

##### Parallel Scavenge 收集器
Parallel Scavenge 收集器是一个新生代收集器, 也是使用复制算法的收集器, 也是并行的多线程收集器; 但它的特点是与其他收集器关注点不同, Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量; 所谓吞吐量就是 CPU 用于运行用户代码时间和 CPU 总消耗时间的比值, 即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间), 虚拟机总共运行了 100 分钟, 其中垃圾收集占 1 分钟, 那吞吐量就是 99 %  
停顿时间越短就越适合需要与用户交互的程序, 良好的响应速度能提升用户体验; 而高吞吐量则可以高效率的利用 CPU 时间, 尽快完成程序的运算任务, 更适合在后台运算而不需要太多交互的任务  
Paralle Scavenge 收集器提供了两高个参数用于精确控制吞吐量, 分别是控制最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX: GCTimeRatio 参数; MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒值, 收集器尽可能的保证内存回收花费的时间不超过设定值, 但 GC 停顿时间是以牺牲吞吐量和新生代空间换取的; GCTimeRatio 参数允许一个大于 0 且小于 100 的整数, 这也就是垃圾收集时间与用户代码运行时间比率的倒数; 默认是 99, 即允许最大 1% (1 / (1 + 99)) 的垃圾时间  
由于与吞吐量关系密切, Paralle Scavenge 收集器也常被称为 "吞吐量优先" 收集器; 除上述参数外, Paralle Scavenge 收集器还有一个参数 =XX:+UseAdaptiveSizePolicy 参数, 当此参数打开后就不需要手工指定大部分细节参数了, 虚拟机会根据当前系统的运行情况收集性能监控信息动态调整参数, 只需要手工设置好 -Xmx, MaxGCPauseMillis, GCTimeRatio 等参数即可; 这种方式也称为 GC 自适应的调节策略

##### Serial Old 收集器
Serial Old 是 Serial 收集器的老年代版本, 同样是一个单线程收集器, 使用 "标记-整理" 算法; 这个收集的主要意义也是在于给 Client 模式下的虚拟机使用的; 如果在 Server 模式下主要有两大用途: 一种用途是在 JDK 1.5 以及之前的版本中于 Paralle Scavenge 收集器搭配使用, 另一种用途就是作为 CMS 收集器的后备方案, 在并发收集发生 Concurrent Mode Failure 时使用  

##### Parallel Old 收集器
Parallel Old 是 Parallel Scavenge 收集器的老年代版本, 使用多线程和 "标记 - 整理" 算法; 这个收集器在 JDK 1.6 中才开始提供, 在此之前新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态, 因为老年代收集器只能选 Serial Old 收集器, 因为 CMS 收集器不支持; 由于老年代收集拖累了 Parallel Scavenge 收集器, 所以在老年代很大且硬件比较高级的环境中, Parallel Scavenge 收集器与 Serial Old 收集器的组合的吞吐量不一定比 ParNew + CMS 好; 直到有了 Parallel Old 收集器, 所以在注重吞吐量以及 CPU 资源敏感的场景可优先考虑 Parallel Scavenge + Parallel Old 组合  

##### CMS 收集器
CMS (Concurrent Mark Sweep) 收集器是一种以获取最短停顿时间为目标的收集器, 从名字上可以看出 CMS 收集器是居于 "标记 - 清除" 算法实现的, 它的运作过程相对于前几种收集器来说更复杂一些, 整个过程分为 4 个步骤
- 初始标记
- 并发标记
- 重新标记
- 并发清除

其中, 初始标记和重新标记这两个步骤仍然需要 "Stop The World"; 初始标记仅仅是标记一下 GC Roots 能直接关联到的对象, 速度很快; 并发标记就是进行 GC Roots Tracing 的过程; 而重新标记则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 这个阶段的停顿时间一般会比初始标记阶段稍长一些, 但远比并发标记的时间短  
由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作, 所以总体上来说, CMS 收集器的内存回收过程是用户线程一起并发执行的; CMS 是一款优秀的收集器, 它主要在于并发收集和低停顿; 但 CMS 远达不到完美的程度, 它有以下三个缺点
- CMS 收集器对 CPU 资源非常敏感: 在并发阶段虽然不会导致用户线程停顿, 但是因为占用了一部分线程 (或者说 CPU 资源)
而导致应用程序变慢, 总吞吐量变低; CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4, 也就是当 CPU 在 4 个以上时, 并发回收时垃圾收集线程不少于 25% 的 CPU 资源, 并且随着 CPU 数量的增加而下降; 但当 CPU 不足 4 个时, CMS 对用户程序的影响就可能变得很大; 为了应付这种情况, 虚拟机提供了一种称为 "增量式并发收集器 (Incremental Concurrent Mark Sweep / i-CMS)" 的 CMS 收集器变种, 使用抢占式模拟多任务机制的思想一样, 就是在并发标记, 清理的时候让 GC 线程, 用户线程交替运行, 尽量减少 GC 线程的独占资源的时间, 这样整个垃圾收集的过程会更长, 但对用户程序的影响就会显的少一些; 但实践证明, 增量式的 CMS 收集器效果很一般, 已不再提倡用户使用  
- CMS 收集器无法处理浮动垃圾 (Floating Gaebage), 可能出现 "Concurrent Mode Failure" 失败而导致另一次 Full GC 的产生: 由于 CMS 并发清理阶段用户线程还在运行着, 伴随程序运行自然就还会有新的垃圾不断产生, 这一部分垃圾出现在标记之后, CMS 无法在当次收集中处理掉它们, 只好留待下一次 GC 时再清理掉, 这一部分垃圾就称为 "浮动垃圾"; 也是由于再垃圾收集阶段用户线程还需要运行, 就需要预留足够的内存空间给用户线程使用, 因此 CMS 收集器不能像其他收集器那样等到老年代几乎用完再进行收集, 需要预留一部分空间提供并发收集时的程序运行使用; 在 JDK 1.5 的默认设置下, CMS 收集器当老年代使用了 68% 的空间后就会被激活, 这是一个偏保守的设置, r如果在应用中老年代增长的不是太快, 可以适当调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比, 以便降低内存回收次数而获得更好的性能, 在 JDK 1.6 中, CMS 收集器的启动阈值已经提升至 92%; 要是 CMS 运行期间预留的内存无法满足程序需要, 就会出现一次 "Concurrent Mode Failure" 失败, 这时虚拟机将启动后备预案: 临时启动 Serial Old 收集器来重新进行老年代的垃圾收集, 这样停顿时间就很长了; 所以参数 -XX:CMSInitiatingOccupancyFraction 设置的太高很容易导致大量 "Concurrent Mode Failure" 失败, 性能反而降低  
- CMS 是一款基于 "标记 - 清除" 算法实现的收集器, 这意味着收集结束时会有大量空间碎片产生: 空间碎片过多将会给大对象分配带来麻烦, 会出现老年代还有很大空间但无法找到足够大的连续空间分配对象, 不得不提前触发一次 Full GC; 为了解决这个问题, CMS 收集器提供了一个 -XX:+UseCMSCompactAtFullCollection 开关参数 (默认开启), 用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程, 内存整理的过车是无法并发的, 空间的问题解决了但停顿时间不得不变长; 还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction, 这个参数是用于设置多少次不压缩的 Full GC 后, 跟着来一次压缩的 (默认为 0, 表示每次进入 Full GC 时都进行碎片整理)
