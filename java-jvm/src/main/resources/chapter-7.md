### 虚拟机类加载机制
代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步

#### 概述
虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 转换解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型, 这就是虚拟机的类加载机制  
与那些在编译时需要进行连接工作的语言不同, Java 语言里的类型加载, 连接, 初始化过程都是在程序运行期间完成的, 这种策略虽然会令类加载时稍微增加一些性能开销, 但是会为 Java 应用程序提供高度的灵活性, Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的  

#### 类加载的时机
类从被加载到虚拟机内存中, 到卸载出内存为止, 它的整个生命周期包括: 加载 (Loading), 验证 (Verification), 准备 (Preparation), 解析 (Resolution), 初始化 (Initialization), 使用 (Using), 卸载 (Unloading) 7 个阶段; 其中验证, 准备, 解析 3 个部分统称为连接 (Linking)  
加载, 验证, 准备, 初始化和卸载这 5 个阶段的顺序是确定的, 类的加载过程必须按照这种顺序按部就班的开始, 而解析阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始, 这是为了支持 Java 语言的运行时绑定 (也称为动态绑定或晚期绑定); 什么情况下需要开始类加载过程的第一个阶段: 加载? Java 虚拟机规范中并没有进行强制约束, 这由虚拟机的具体实现来自由把握; 但对于初始化阶段, 虚拟机规范则是严格规定了**有且只有** 5 种情况必须立即对类进行 "初始化" (加载, 验证, 准备自然要在此之前进行)  
- 遇到 new, getstatic, putstatic, invokestatic 这 4 条字节码指令是, 如果类没有进行过初始化, 则需要先触发初始化; 生成这 4 条指令的最常见的 Java 代码场景是: 使用 new 关键字实例化对象时, 读取或设置一个类的静态字段 (被 final 修饰, 已在编译器把结果放入常量池的静态字段除外) 时, 以及调用一个类的静态方法时
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候, 如果类没有进行过初始化则需要先触发初始化
- 当初始化一个类时, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化
- 当虚拟机启动时, 用户需要指定一个执行的主类 (包含 main 方法的那个类), 虚拟机会先初始化这个主类
- 当使用 JDK 1.7 的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后解析结果 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄, 并且这个方法句柄所对应的类还没有进行过初始化, 则需要先触发其初始化

对于以上 5 种会触发类进行初始化的行为称为对一个类进行主动引导; 除此之外, 所有引用类的方式都不会触发初始化, 称为被动引用
- 通过子类因用户父类的静态字段, 不会导致子类初始化
- 通过数组定义来引用类, 不会触发此类的初始化
- 常量在编译阶段会存入调用类的常量池中, 本质上并没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化

接口的加载过程与类加载过程稍有不同, 针对接口需要做一些特殊说明: 接口也有初始化过程, 编译器会为接口生成 "<clinit>()" 类构造器, 用于初始化接口中所定义的成员变量; 接口与真正有所区别的是前面讲述的 5 种情景中的第 3 种: 当一个类在初始化时, 要求其父类全部都已经初始化过了, 但是一个接口在初始化时, 并不要求其父接口全部都完成了初始化, 只有在真正使用到了父接口的时候 (如引用接口种定义的常量) 才会初始化

#### 类加载的过程
类加载的全过程, 也就是加载, 验证, 准备, 解析和初始化这 5 个阶段所执行的具体动作

##### 加载
加载时类加载过程的一个阶段, 在加载阶段, 虚拟机需要完成一下 3 件事
- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问接口

以上的虚拟机规范并不算具体, 因此虚拟机实现与具体应用的灵活度都是相当大的;  例如获取二进制字节流并没有规定从哪里获取, 怎样获取等等; Java 发展历程中, 许多举足轻重的 Java 技术都建立在这一基础之上
- 从 ZIP 包中读取, 最终成为日后 JAR, EAR, WAR 格式的基础
- 从网络中读取, 最典型的应用就是 Applet
- 运行时计算生成, 这种场景使用的最多的就是动态代理技术, 在 java.lang.reflect.Proxy 中, 就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 "\*$Proxy" 的代理类的二进制字节流
- 由其他文件生成, 典型场景时 JSP 应用, 即由 JSP 文件 生成对应的 Class 类
- 从数据库中读取, 这种场景相对少见; 例如某些中间件服务器 (SAP Netweaver) 可以选择把程序安装到数据库中来完成程序代码在集群间的分发

相对类加载过程的其他阶段, 一个非数组类的加载阶段 (准确的说是加载阶段中获取类的二进制字节流的动作) 是开发人员可控性最强的, 因为加载阶段既可以使用系统提供的引导类加载器来完成, 也可以由用户自定义的类加载器去完成, 开发人员可以通过定义自己的类加载器去控制字节流的获取方式 (即重写一个类加载器的 loadClass() 方法)  
对于数组类而言情况就有所不同, 数组类本身不通过类加载器创建, 它是由 Java 虚拟机直接创建的, 但数组类与类加载器仍然有很密切的关系, 因为数组类的元素类型 (Element Type, 即数组去掉所有维度的类型) 最终是要靠类加载器去创建的, 一个数组类 (下面简称 C) 创建过程就遵顼以下原则
- 如果数组的组件类型 (Component Type, 即数组去掉一个维度的类型) 是引用类型, 那就递归采用本节定义的加载过程去加载这个组件类型, 数组 C 将在加载该组件类型的类加载器的类名称空间上被标识
- 如果数组的组件类型不是引用类型 (例如 int[] 数组), Java 虚拟机将会把数组 C 标记为与引导类加载器关联
- 数组类的可见性与它的组件类型可见性一致, 如果组件类型不是引用类型, 那数组类的可见性将默认为 public

加载阶段完成后, 虚拟机外部的二进制字节来就按照虚拟机所需的格式存储在方法区之中, 方法去中的数据存储格式由虚拟机实现自行定义, 虚拟机规范未规定此区域的具体数据结构; 然后在内存中实例化一个 java.lang.Class 类的对象 (并没有明确规定是在 Java 堆中, 对于 HotSpot 虚拟机而言, Class 对象比较特殊, 虽然是对象但是存放在方法区里), 这个对象将作为程序访问方法去中的这些类型数据的外部接口  
加载阶段和连接阶段的部分内容是交叉进行的, 加载阶段尚未完成, 连接阶段可能已经开始了, 但这些夹在加载阶段中的进行的动作, 仍然属于连接阶段的内容, 这两个阶段的开始时间仍然保持着固定的先后顺序

##### 验证
