### 虚拟机类加载机制
代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步

#### 概述
虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 转换解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型, 这就是虚拟机的类加载机制  
与那些在编译时需要进行连接工作的语言不同, Java 语言里的类型加载, 连接, 初始化过程都是在程序运行期间完成的, 这种策略虽然会令类加载时稍微增加一些性能开销, 但是会为 Java 应用程序提供高度的灵活性, Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的  

#### 类加载的时机
类从被加载到虚拟机内存中, 到卸载出内存为止, 它的整个生命周期包括: 加载 (Loading), 验证 (Verification), 准备 (Preparation), 解析 (Resolution), 初始化 (Initialization), 使用 (Using), 卸载 (Unloading) 7 个阶段; 其中验证, 准备, 解析 3 个部分统称为连接 (Linking)  
加载, 验证, 准备, 初始化和卸载这 5 个阶段的顺序是确定的, 类的加载过程必须按照这种顺序按部就班的开始, 而解析阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始, 这是为了支持 Java 语言的运行时绑定 (也称为动态绑定或晚期绑定); 什么情况下需要开始类加载过程的第一个阶段: 加载? Java 虚拟机规范中并没有进行强制约束, 这由虚拟机的具体实现来自由把握; 但对于初始化阶段, 虚拟机规范则是严格规定了**有且只有** 5 种情况必须立即对类进行 "初始化" (加载, 验证, 准备自然要在此之前进行)  
- 遇到 new, getstatic, putstatic, invokestatic 这 4 条字节码指令是, 如果类没有进行过初始化, 则需要先触发初始化; 生成这 4 条指令的最常见的 Java 代码场景是: 使用 new 关键字实例化对象时, 读取或设置一个类的静态字段 (被 final 修饰, 已在编译器把结果放入常量池的静态字段除外) 时, 以及调用一个类的静态方法时
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候, 如果类没有进行过初始化则需要先触发初始化
- 当初始化一个类时, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化
- 当虚拟机启动时, 用户需要指定一个执行的主类 (包含 main 方法的那个类), 虚拟机会先初始化这个主类
- 当使用 JDK 1.7 的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后解析结果 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄, 并且这个方法句柄所对应的类还没有进行过初始化, 则需要先触发其初始化

对于以上 5 种会触发类进行初始化的行为称为对一个类进行主动引导; 除此之外, 所有引用类的方式都不会触发初始化, 称为被动引用
- 通过子类因用户父类的静态字段, 不会导致子类初始化
- 通过数组定义来引用类, 不会触发此类的初始化
- 常量在编译阶段会存入调用类的常量池中, 本质上并没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化

接口的加载过程与类加载过程稍有不同, 针对接口需要做一些特殊说明: 接口也有初始化过程, 编译器会为接口生成 "<clinit>()" 类构造器, 用于初始化接口中所定义的成员变量; 接口与真正有所区别的是前面讲述的 5 种情景中的第 3 种: 当一个类在初始化时, 要求其父类全部都已经初始化过了, 但是一个接口在初始化时, 并不要求其父接口全部都完成了初始化, 只有在真正使用到了父接口的时候 (如引用接口种定义的常量) 才会初始化

#### 类加载的过程
类加载的全过程, 也就是加载, 验证, 准备, 解析和初始化这 5 个阶段所执行的具体动作

##### 加载
加载时类加载过程的一个阶段, 在加载阶段, 虚拟机需要完成一下 3 件事
- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问接口

以上的虚拟机规范并不算具体, 因此虚拟机实现与具体应用的灵活度都是相当大的;  例如获取二进制字节流并没有规定从哪里获取, 怎样获取等等; Java 发展历程中, 许多举足轻重的 Java 技术都建立在这一基础之上
- 从 ZIP 包中读取, 最终成为日后 JAR, EAR, WAR 格式的基础
- 从网络中读取, 最典型的应用就是 Applet
- 运行时计算生成, 这种场景使用的最多的就是动态代理技术, 在 java.lang.reflect.Proxy 中, 就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 "\*$Proxy" 的代理类的二进制字节流
- 由其他文件生成, 典型场景时 JSP 应用, 即由 JSP 文件 生成对应的 Class 类
- 从数据库中读取, 这种场景相对少见; 例如某些中间件服务器 (SAP Netweaver) 可以选择把程序安装到数据库中来完成程序代码在集群间的分发

相对类加载过程的其他阶段, 一个非数组类的加载阶段 (准确的说是加载阶段中获取类的二进制字节流的动作) 是开发人员可控性最强的, 因为加载阶段既可以使用系统提供的引导类加载器来完成, 也可以由用户自定义的类加载器去完成, 开发人员可以通过定义自己的类加载器去控制字节流的获取方式 (即重写一个类加载器的 loadClass() 方法)  
对于数组类而言情况就有所不同, 数组类本身不通过类加载器创建, 它是由 Java 虚拟机直接创建的, 但数组类与类加载器仍然有很密切的关系, 因为数组类的元素类型 (Element Type, 即数组去掉所有维度的类型) 最终是要靠类加载器去创建的, 一个数组类 (下面简称 C) 创建过程就遵顼以下原则
- 如果数组的组件类型 (Component Type, 即数组去掉一个维度的类型) 是引用类型, 那就递归采用本节定义的加载过程去加载这个组件类型, 数组 C 将在加载该组件类型的类加载器的类名称空间上被标识
- 如果数组的组件类型不是引用类型 (例如 int[] 数组), Java 虚拟机将会把数组 C 标记为与引导类加载器关联
- 数组类的可见性与它的组件类型可见性一致, 如果组件类型不是引用类型, 那数组类的可见性将默认为 public

加载阶段完成后, 虚拟机外部的二进制字节来就按照虚拟机所需的格式存储在方法区之中, 方法去中的数据存储格式由虚拟机实现自行定义, 虚拟机规范未规定此区域的具体数据结构; 然后在内存中实例化一个 java.lang.Class 类的对象 (并没有明确规定是在 Java 堆中, 对于 HotSpot 虚拟机而言, Class 对象比较特殊, 虽然是对象但是存放在方法区里), 这个对象将作为程序访问方法去中的这些类型数据的外部接口  
加载阶段和连接阶段的部分内容是交叉进行的, 加载阶段尚未完成, 连接阶段可能已经开始了, 但这些夹在加载阶段中的进行的动作, 仍然属于连接阶段的内容, 这两个阶段的开始时间仍然保持着固定的先后顺序

##### 验证
验证是连接阶段的第一步, 这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机的自身安全  
验证阶段是非常重要的, 这个阶段是否严谨直接决定了 Java 虚拟机是否能承受恶意代码的攻击; 从执行性能的角度上讲, 验证阶段的工作量在虚拟机的类加载子系统中占了相当大的一部分; 如果验证到输入的字节流不符合 Class 文件格式的约束, 虚拟机就应抛出一个 java.lang.VerifyError 异常或其子类异常; 验证阶段大致会完成下面 4 个阶段的检验动作: 文件格式验证, 元数据验证, 字节码验证, 符号引用验证

###### 文件格式验证
第一阶段要验证字节流是否符合 Class 文件格式的规范, 并且能被当前版本的虚拟机处理; 这一阶段可能包括下面这些验证点
- 是否以魔数 0xCAFEBABE 开头
- 主次版本号是否在当前虚拟机处理范围之内
- 常量池的常量中是否有不被支持的常量类型 (检查常量 tag 标记)
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
- CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据
- Class 文件中各个部分及文件本身是否有被删除的或附件的其他信息
- ...

这一阶段的验证点远不止这些, 该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区内; 通过这个阶段地验证后, 字节流才会进入内存地方法区中进行存储, 后续验证阶段都是基于方法区的存储结构进行的, 不会再直接操作字节流

###### 元数据验证
第二阶段是对字节码描述的信息进行语义分析, 以保证其描述的信息符合 Java 语言规范的要求; 这一阶段可能包括的验证点如下
- 这个类是否有父类
- 这个类的父类是否继承了不允许被继承的类 (被 final 修饰的类)
- 如果这个类不是抽象类, 是否实现了其父类或接口之中要求实现的所有方法
- 类中的字段, 方法是否于父类产生矛盾 (例如覆盖了父类的 final 字段, 或者出现不符合规则的方法重载, 如方法参数一致但返回值类型却不同等)
- ...

这一阶段的主要目的是对类的元数据信息进行语义校验, 保证不存在不符合 Java 语言规范的元数据信息

###### 字节码验证
第三阶段是整个验证过程中最复杂的阶段, 主要目的是通过数据流和控制流分析, 确定程序语义是合法的, 符合逻辑的; 在第二阶段对元数据信息中的数据类型做完校验后, 这个阶段将对类的方法体进行校验分析, 以保证被校验的类方法在运行时不会做出危害虚拟机的安全事件
- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作; 不会出现: 在操作栈放置了一个 int 类型的数据, 使用时却按 long 类型来加载入本地变量表中
- 保证跳转指令不会跳转到方法体以外的字节码指令上
- 保证方法体的类型转换时有效的; 例如可以把一个子类对象赋值给父类数据类型, 这是安全的, 但是把父类对象赋值给子类数据类型则是危险和不合法的
- ...

这里方法体通过了字节码验证也不能说一定就是安全的, 这里涉及了离散数学中一个很著名的问题 "Halting Problem": 通过程序去校验程序逻辑是无法做到绝对准确的 --- 不能通过程序准确地检查出程序是否能在有限地时间内结束运行  
在 JDK 1.6 之后地 Javac 编译器和 Java 虚拟机中斤进行了一项优化, 给方法体地 Code 属性的属性表中增加了一项名为 "StackMapTable" 的属性, 这项属性描述了方法体中所有的基本块 (Basic Block, 按照控制流拆分的代码块) 开始时本地变量表和操作栈应有的状态, 在字节码验证期间, 就不需要根据程序推到这些状态的合法性, 只需要检查 StackMapTable 属性中的记录是否合法即可; 这样将字节码的类型推导转变为类型检查从而节省了一些时间  
在 JDK 1.6 的 HotSpot 虚拟机中提供了 -XX:-UseSplitVerifier 选项来关闭这项优化, 或者使用参数 -XX:+FailOverToOldVerifier 要求类型校验失败时退回到旧的类型推导方式进行校验; 在 JDK 1.7 之后, 对于主版本号大于 50 的 Class 文件, 使用类型检查来完成数据流分析则是唯一的选择

###### 符号引用验证
最后一阶段的校验发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在连接的第三阶段 --- 解析阶段中发生; 符号引用验证可以看作是对类自身以外 (常量池中各种符号引用) 的信息进行匹配性校验, 通常需要校验以下内容
- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
- 符号引用中的类, 字段, 方法的访问性是否可被当前类访问
- ...

符号引用验证的目的是确保解析动作能正常执行, 如果无法通过符号引用验证, 那么将抛出一个 java.lang.IncompatibleClassChangeError 异常的子类, 如 java.lang.IllegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError 等  
对于虚拟机的类加载机制来说, 验证阶段是一个非常重要的, 但不是一定必要的阶段; 可以使用 -Xverify:none 参数来关闭大部分的类验证措施, 以缩短虚拟机类加载的时间

##### 准备
准备阶段是正式为类变量 (被 static 修饰的变量) 分配并设置类变量初始值的阶段, 这些变量所使用的内存都将在方法区中进行分配; 这里说的初始值通常情况下是数据类型的零值, 假设一个类变量的定义为: `public static int value = 123;`, 那变量 value 在准备阶段过后的初始值是 0 而不是 123; 因为这是尚未开始执行任何 Java 方法, 而把 value 赋值为 123 的 putstatic 指令是程序被编译后, 存放于类构造器 <clinit>() 方法中, 所以将 value 赋值为 123 的动作将在初始化阶段才会执行; 下表是 Java 中所有基本数据类型的零值
|数据类型|零值|数据类型|零值|
|-|-|-|-|
|int|0|boolean|false|
|long|0L|float|0.0f|
|short|(short)0|double|0.0d|
|char|'\u0000'|reference|null|
|byte|(byte)0|-|-|
在通常情况下初始值是零值, 如果类字段的字段属性表中存在 ConstantValue 属性, 那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值, 例如: `public static final int value = 123;`, 编译时 Javac 将会为 value 生成 ConstantValue 属性, 在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123

##### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
- 符号引用 (Symbolic Reference): 符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可; 符号引用与虚拟机实现地内存布局无关, 引用地目标并不定已加载到内存中; 各种虚拟机实现的内存布局可以各不相同, 但是它们能接受的符号必须都是一致的, 因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中
- 直接引用 (Direct Reference): 直接引用可以是直接指向目标的指针, 相对偏移量或是一个能间接定位到目标的句柄; 直接引用是和虚拟机实现的内存布局相关的, 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同; 如果有了直接引用, 那引用的目标必定已经在内存中存在了

虚拟机规范中并未规定解析阶段发生的具体时间, 只要求了在执行 anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecicial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic 这 16 个用于操作符号引用的字节码指令之前, 先对它们所使用的符号引用进行解析; 所以虚拟机实现可以根据需要来判断是在类被加载器加载时就对常量池的符号引用进行解析, 还是等到一个符号引用将要被使用前才去解析它  
对同一个符号引用进行多次解析请求是很常见的事情, 除了 invokedynamic 指令之外, 虚拟机实现可以对第一次解析的结果进行缓存 (在运行时常量池中记录直接引用, 并把常量标识为已解析状态) 从而避免解析动作重复执行; 无论是否真正执行了多次解析动作, 虚拟机需要保证的是在同一个实体中, 如果一个符号引用之前已经被成功解析过了, 那么后续的引用解析请求就应当一直成功; 同样的, 如果第一次解析失败了, 那么其他指令对这个符号的解析请求也应该收到相同的异常  
对于 invokedynamic 指令上述规则不成立, 因为 invokedynamic 指令的目的本来就是用于动态语言支持, 它所对应的引用称为 "动态调用点限定符" (Dynamic Call Site Specifier), 即代码程序实际运行到这条指令的时候, 解析动作才能进行; 相对的, 其余可触发解析的指令都是静态的, 可以在刚刚完成加载阶段, 还没有开始执行代码时就进行解析  
解析动作主要针对类或接口, 字段, 类方法, 接口方法, 方法类型, 方法句柄, 调用点限定符 7 类符号引用进行, 分别对应于常量池的 CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info, CONSTANT_MethodType_info, CONSTANT_MethodHandle_info, CONSTANT_InvokeDynamic_info 这 7 种常量类型
###### 类或接口的解析
假设当前代码所处的类为 D, 如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用, 虚拟机需要完成整个解析过程需要以下三个步骤
- 如果 C 不是一个数组类型, 那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C; 在加载过程中, 由于元数据验证, 字节码验证的需要, 又可能触发其他相关类的加载动作, 例如加载这个类的父类或实现的接口; 一旦这个加载过程出现了任何异常, 解析过程就宣告失败
- 如果 C 是一个数组类型, 并且数组的元素类型为对象, N 的描述符会类似为 "[Ljava/lang/Integer" 的形式, 那将会按照第一点的规则去加载数组元素类型; 如果 N 的描述符如前面所假设的形式, 那么需要加载的元素类型就是 "java.lang.Integer", 接着由虚拟机生成一个代表数组维度和元素的数组对象
- 如果上面的步骤没有出现任何异常, 那么 C 在虚拟机中实际上已经成为了一个有效的类或接口了, 但在解析完成之前还要进行符号引用验证, 确认 D 是否具有对 C 的访问权限; 如果发现不具备访问权限, 则抛出 java.lang.IllegalAccessError 异常
