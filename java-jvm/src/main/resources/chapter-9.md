### 虚拟机字节码执行引擎
代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步

#### 概述
在 Class 文件格式与执行引擎这部分中, 用户程序能直接影响的内容并不太多, Class 文件以何种格式存储, 类型何时加载, 如何连接, 以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为, 用户程序无法对其进行改变; 能通过程序进行操作的, 主要是字节码生成和类加载器这两部分的功能

#### 案例分析
以下四个案例中, 类加载器和字节码的案例各有两个

##### Tomcat: 正统的类加载器架构
主流的 Java Web 服务器, 如 Tomcat , Jetty, WebLogic, WebSphere 等, 都实现了自己定义的类加载器 (一般不止一个); 因为一个功能健全的 Web 服务器要解决以下几个问题
- 部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离; 两个不同的应用程序可能会依赖同一个第三方类库的不同版本, 不能要求一个类库在一个服务器中只有一份, 服务器应当保证两个应用程序的类库可以相互独立使用
- 部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以互相共享; 如果有多个应用部署时, 如果类库不能共享, 虚拟机的方法区就会很容易出现过度膨胀的风险
- 服务器需要尽可能的保证自身的安全不受部署的 Web 应用程序影响; 目前有许多主流服务器也是由 Java 语言来实现的; 因此服务器本身也有类库依赖的问题, 基于安全考虑, 服务器所使用的类库应该与应用程序的类库互相独立
- 支持 JSP 应用的 Web 服务器, 大多数都需要支持 HotSwap 功能; 但 JSP 文件最终要编译成 Class 文件才可以由虚拟机执行, 但 JSP 文件由于其纯文本的特性, 运行时修改的概率远远大于第三方类库或者程序本身

由于上述问题, 在部署 Web 应用时, 单独的一个 ClassPath 就无法满足需求了, 所以各种 Web 服务器都不约而同的提供了好几个 ClassPath 路径供用户存放第三方类库, 这些路径一般都以 `lib` 或 `classes` 命名; 被放置到不同的路径中的类库, 具备不同的访问范围和服务对象, 通常每一个目录都会有相应的自定义类加载器去加载放置在里面的 Java 类库
